
#### 1 ~ 200

| 1 ~ 100                                                      | 101 ~ 200                                                    |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
|                                                              | [#101-symmetric-tree-easy](#101-symmetric-tree-easy)         |
|                                                              | [#102-level-order-traversal-medium](#102-level-order-traversal-medium) |
|                                                              | [#103-zigzag-level-order-traversal-medium](#103-zigzag-level-order-traversal-medium) |
|                                                              | **[#105-construct-tree-preorder-inorder-medium](#105-construct-tree-preorder-inorder-medium)** |
|                                                              | [#106-construct-tree-inorder-postorder-medium](#106-construct-tree-inorder-postorder-medium) |
|                                                              | **[#109-sorted-list-to-bst-medium](#109-sorted-list-to-bst-medium)** |
| [#10-regular-expression-match-hard](#10-regular-expression-match-hard) | [#110-balanced-binary-tree-easy](#110-balanced-binary-tree-easy) |
|                                                              | [#111-min-depth-of-binary-tree-easy](#111-min-depth-of-binary-tree-easy) |
|                                                              | [#112-path-sum-easy](#112-path-sum-easy)                     |
|                                                              | [#113-path-sum-ii-medium](#113-path-sum-ii-medium)           |
|                                                              | [#114-flatten-binary-tree-to-linked-list-medium](#114-flatten-binary-tree-to-linked-list-medium) |
|                                                              | **[#115-distinct-subsequences-hard](#115-distinct-subsequences-hard)** |
|                                                              | **[#116-populating-next-right-pointer-medium](#116-populating-next-right-pointer-medium)** |
|                                                              | [#120-triangle-medium](#120-triangle-medium)                 |
|                                                              |                                                              |
| [#22-generate-parentheses-medium](#22-generate-parentheses-medium) |                                                              |
|                                                              | [#130-surrounded-regions](#130-surrounded-regions)           |
| [#32-longest-valid-parentheses-hard](#32-longest-valid-parentheses-hard) |                                                              |
| [#33-search-in-rotated-sorted-array-medium](#33-search-in-rotated-sorted-array-medium) | [#133-clone-graph-medium](#133-clone-graph-medium)           |
|                                                              | [#136-single-number-easy](#136-single-number-easy)           |
| [#38-count-and-say-easy](#38-count-and-say-easy)             |                                                              |
| [#42-trapping-rain-water-hard](#42-trapping-rain-water-hard) |                                                              |
|                                                              | [#146-lru-cache-hard](#146-lru-cache-hard)                   |
|                                                              | [#149-max-points-on-a-line-hard](#149-max-points-on-a-line-hard) |
|                                                              | [#156-binary-tree-upside-down-medium](#156-binary-tree-upside-down-medium) |
| [#61-rotate-list-medium](#61-rotate-list-medium)             |                                                              |
| [#62-unique-paths-medium](#62-unique-paths-medium)           |                                                              |
| [#63-unique-paths-ii-medium](#63-unique-paths-ii-medium)     | [#163-missing-ranges-medium](#163-missing-ranges-medium)     |
| [#64-minimum-path-sum-medium](#64-minimum-path-sum-medium)   |                                                              |
|                                                              | [#165-compare-version-numbers-medium](#165-compare-version-numbers-medium) |
| [#66-plus-one-easy](#66-plus-one-easy)                       |                                                              |
| [#67-add-binary-easy](#67-add-binary-easy)                   |                                                              |
|                                                              |                                                              |
|                                                              | [#169-majority-element-easy](#169-majority-element-easy)     |
| [#70-climbing-stairs-easy](#70-climbing-stairs-easy)         |                                                              |
| [#71-simplify-path-medium](#71-simplify-path-medium)         |                                                              |
| [#72-edit-distance-hard](#72-edit-distance-hard)             |                                                              |
| [#73-set-matrix-zeros-medium](#73-set-matrix-zeros-medium)   |                                                              |
| [#74-search-a-2d-matrix-medium](#74-search-a-2d-matrix-medium) |                                                              |
| [#75-sort-colors-medium](#75-sort-colors-medium)             |                                                              |
| [#76-minimun-window-substring-hard](#76-minimun-window-substring-hard) |                                                              |
| [#77-combinations-medium](#77-combinations-medium)           |                                                              |
| [#78-subsets-medium](#78-subsets-medium)                     |                                                              |
| [#79-word-search-medium](#79-word-search-medium)             |                                                              |
| [#80-remove-duplicates-from-sorted-array-ii-medium](#80-remove-duplicates-from-sorted-array-ii-medium) |                                                              |
| [**#81-search-in-rotated-sorted-array-ii-medium**](#81-search-in-rotated-sorted-array-ii-medium) |                                                              |
| [#82-remove-duplicates-from-sorted-list-ii-medium](#82-remove-duplicates-from-sorted-list-ii-medium) |                                                              |
| [#83-remove-duplicates-from-sorted-list-easy](#83-remove-duplicates-from-sorted-list-easy) |                                                              |
| [#84-largest-rectangle-in-histogram-hard](#84-largest-rectangle-in-histogram-hard) |                                                              |
|                                                              |                                                              |
| [#86-partition-list-medium](#86-partition-list-medium)       |                                                              |
| [#87-scramble-string-hard](#87-scramble-string-hard)         |                                                              |
| [#88-merge-sorted-array-easy](#88-merge-sorted-array-easy)   |                                                              |
| [#89-gray-code-medium](#89-gray-code-medium)                 |                                                              |
| [#90-subsets-ii-medium](#90-subsets-ii-medium)               |                                                              |
|                                                              |                                                              |
| [#92-reverse-linked-list-ii-medium](#92-reverse-linked-list-ii-medium) |                                                              |
| [#93-restore-ip-addresses-medium](#93-restore-ip-addresses-medium) |                                                              |
| [#94-binary-tree-inorder-traversal-medium](#94-binary-tree-inorder-traversal-medium) |                                                              |
| [#97-interleaving-string-hard](#97-interleaving-string-hard) |                                                              |
| [#98-validate-binary-search-tree-medium](#98-validate-binary-search-tree-medium) |                                                              |
| [#100-same-tree-easy](#100-same-tree-easy)                   |                                                              |

#### 201 ~ 400

| 201 ~ 300                                                    | 301 ~ 400                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [#201-bitwise-and-of-numbers-range-medium](#201-bitwise-and-of-numbers-range-medium) |                                                              |
| [#204-count-primes-easy](#204-count-primes-easy)             |                                                              |
|                                                              | [#313-supper-ugly-number-medium](#313-supper-ugly-number-medium) |
| [#217-contains-duplicate-easy](#217-contains-duplicate-easy) |                                                              |
| [#219-contains-duplicate-ii-easy](#219-contains-duplicate-ii-easy) |                                                              |
| [#220-contains-duplicate-iii-medium](#220-contains-duplicate-iii-medium) |                                                              |
| [#223-rectangle-area-medium](#223-rectangle-area-medium)     |                                                              |
| [#228-summary-ranges-medium](#228-summary-ranges-medium)     |                                                              |
| [#229-majority-element-ii-medium](#229-majority-element-ii-medium) |                                                              |
|                                                              | [#335-self-crossing-hard](#335-self-crossing-hard)           |
| [#241-different-ways-to-add-parentheses-medium](#241-different-ways-to-add-parentheses-medium) |                                                              |
|                                                              |                                                              |
| [#243-shortest-word-distance-easy](#243-shortest-word-distance-easy) |                                                              |
| [#244-shortest-word-distance-ii-medium](#244-shortest-word-distance-ii-medium) |                                                              |
| [#245-shortest-word-distance-iii-medium](#245-shortest-word-distance-iii-medium) |                                                              |
| [#263-ugly-number-easy](#263-ugly-number-easy)               |                                                              |
| [#271-encode-and-decode-strings-medium](#271-encode-and-decode-strings-medium) | **[#371-sum-of-two-integers-easy](#371-sum-of-two-integers-easy)** |
| [#279-perfect-squares-medium](#279-perfect-squares-medium)   |                                                              |
|                                                              | [#384-shuffle-an-array-medium](#384-shuffle-an-array-medium) |
|                                                              | [#388-longest-absolute-file-path-medium](#388-longest-absolute-file-path-medium) |

#### 401 ~ 600

| 401 ~ 500                                                    | 501 ~ 600                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |
| [#406-queue-reconstruction-by-height-medium](#406-queue-reconstruction-by-height-medium) |                                                              |
| [#419-battleships-in-a-board-medium](#419-battleships-in-a-board-medium) |                                                              |
| **[#443-string-compression-easy](#443-string-compression-easy)** |                                                              |
|                                                              | [#560-subarray-sum-equals-k-medium](#560-subarray-sum-equals-k-medium) |
| [#463-island-perimeter-easy](#463-island-perimeter-easy)     |                                                              |
| [#476-number-complement-easy](#476-number-complement-easy)   |                                                              |
|                                                              |                                                              |
| [#500-keyboard-row-easy](#500-keyboard-row-easy)             |                                                              |

#### 601 ~ 800

| 601 ~ 700                                                    | 701 ~ 800 |
| ------------------------------------------------------------ | --------- |
| [#604-compressed-string-iterator-easy](#604-compressed-string-iterator-easy) |           |
| [#625-minimun-factorization-medium](#625-minimun-factorization-medium) |           |
|                                                              |           |

#### 801 ~ 1000

| 801 ~ 900                                                    | 901 ~ 1000 |
| ------------------------------------------------------------ | ---------- |
| [#809-expressive-word-medium](#809-expressive-word-medium)   |            |
| [#814-binary-tree-pruning-medium](#814-binary-tree-pruning-medium) |            |
| [#817-linked-list-components-medium](#817-linked-list-components-medium) |            |
|                                                              |            |
|                                                              |            |



#### #10-regular-expression-match-hard

Given an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'`.

```
'.' Matches any single character.
'*' Matches zero or more of the preceding element.
```

The matching should cover the **entire** input string (not partial).

**Note:**

- `s` could be empty and contains only lowercase letters `a-z`.
- `p` could be empty and contains only lowercase letters `a-z`, and characters like `.` or `*`.

**Example 1:**

```
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
```

```java
    public boolean isMatch(String s, String p) {
		if (s == null || p == null)
			return false;
		boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
		dp[0][0] = true;
		// initial the first line
		for (int j = 1; j <= p.length(); j++) {
			if (p.charAt(j - 1) == '*')
				dp[0][j] = dp[0][j - 2];
		}
		// dp conditions:
		// (1) p.char == . || p.char == s.char
		// (2) p.char == *:
		// 1. treat as 0 : check i, j-2
		// 2. if p[j-1] == s.char || .: check i-1,j
		for (int i = 1; i <= s.length(); i++) {
			for (int j = 1; j <= p.length(); j++) {
				if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1))
					dp[i][j] = dp[i - 1][j - 1];
				else if (p.charAt(j - 1) == '*') {
					// check * is 0
					dp[i][j] = dp[i][j - 2];
					if (dp[i][j])
						continue;
					// if p.prev equal or .
					if (p.charAt(j - 2) == s.charAt(i - 1) || p.charAt(j - 2) == '.') {
						dp[i][j] = dp[i - 1][j];
					}
				}
			}
		}
		return dp[s.length()][p.length()];
    }
```

---

#### #22-generate-parentheses-medium

Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given *n* = 3, a solution set is:

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

```java
    public List<String> generateParenthesis(int n) {
        // utilizing backtracking
        List<String> result = new ArrayList<>();
        backtrack(result,new StringBuilder(),0,0,n);
        return result;
    }
    private void backtrack(List<String> result,StringBuilder temp,int left,int right,int n){
        if(temp.length() == n * 2){
            result.add(temp.toString());
            return;
        }
        int len = temp.length();
        // append (
        if(left < n){
            temp.append('(');
            backtrack(result,temp,left+1,right,n);
            temp.setLength(len);
        }
        // append )
        if(right < left){
            temp.append(')');
            backtrack(result,temp,left,right+1,n);
            temp.setLength(len);
        }
    }
```



---

#### #32-longest-valid-parentheses-hard

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

For `"(()"`, the longest valid parentheses substring is `"()"`, which has length = 2.

Another example is `")()())"`, where the longest valid parentheses substring is `"()()"`, which has length = 4.

```java
    public int longestValidParentheses(String s) {
        if(s==null || s.length()==0)
            return 0;
        Stack<Integer> stack = new Stack<>();
        stack.push(-1); // for first pair if ()
        int maxLen = 0;
        for(int i=0;i<s.length();i++){
           if(s.charAt(i) == '(')
               stack.push(i);
            else{
                stack.pop();
                if(stack.isEmpty()){
                    stack.push(i);  // first not valid
                }else{
                    maxLen = Math.max(maxLen,i-stack.peek());
                }
            }
        }
        return maxLen;
    }
```

---------------------------------

#### #33-search-in-rotated-sorted-array-medium

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).

You are given a target value to search. If found in the array return its index, otherwise return `-1`.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

```java
    public int search(int[] nums, int target) {
        if(nums==null || nums.length==0)
            return -1;
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right-left)/2;
            if(nums[mid] == target)
                return mid;
            // left half not rotate
            if(nums[left] <= nums[mid]){
                // mid in not rotate part
                if(nums[left]<=target && target<nums[mid])
                    right = mid - 1;
                // mid in rotate part
                else left = mid + 1;
            // right half not rotate
            }else{
                // mid in not rotate part
                if(nums[mid]<target && target<=nums[right])
                    left = mid + 1;
                // mid in rotate part
                else right = mid -1;
            }
        }
        return -1;
    }
```

---

#### 36. Valid Sudoku (medium)

Determine if a Sudoku is valid, according to: [Sudoku Puzzles - The Rules](http://sudoku.com.au/TheRules.aspx).

The Sudoku board could be partially filled, where empty cells are filled with the character `'.'`.

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

A partially filled sudoku which is valid.

**Note:**
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.

```java
    public boolean isValidSudoku(char[][] board) {
        if(board==null || board.length!=9 || board[0].length!=9)
            return false;
        Set<Character> rowSet = new HashSet<>();
        Set<Character> colSet = new HashSet<>();
        Set<Character> cubSet = new HashSet<>();
        // check row, col, cube
        for(int row=0;row<9;row++){
            rowSet.clear();
            colSet.clear();
            cubSet.clear();
            for(int col=0;col<9;col++){
                // left to right
                if(board[row][col]!='.' && !rowSet.add(board[row][col]))
                    return false;
                // up to down
                if(board[col][row]!='.' && !colSet.add(board[col][row]))
                    return false;
                // map to a cube
                int cubeRow = 3 * (row / 3) + col / 3; 
                int cubeCol = 3 * (row % 3) + col % 3;
                if(board[cubeRow][cubeCol]!='.' && !cubSet.add(board[cubeRow][cubeCol]))
                    return false;
            }
        }
        return true;
    }
```

-------

#### 37. Sudoku Solver (hard)

Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character `'.'`.

You may assume that there will be only one unique solution.

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

A sudoku puzzle...

![img](http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)

...and its solution numbers marked in red.

```java
    public void solveSudoku(char[][] board) {
        if(board==null || board.length!=9 || board[0].length!=9)
            return;
        solver(board);
    }
    private boolean solver(char[][] board){
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[i][j] != '.')
                    continue;
                for(char c='1';c<='9';c++){
                    if(isValid(board,i,j,c)){
                        board[i][j] = c;
                        if(solver(board))
                            return true;
                        board[i][j] = '.';
                    }
                }
                return false;
            }
        }
        return true;
    }
    private boolean isValid(char[][] board,int i,int j,char c){
        for(int k=0;k<9;k++){
            if(board[i][k] == c)    return false;
            if(board[k][j] == c)    return false;
            int row = 3 * (i / 3) + k / 3;
            int col = 3 * (j / 3) + k % 3;
            if(board[row][col] == c)    return false;
        }
        return true;
    }
```

-------------

#### #38-count-and-say-easy

The count-and-say sequence is the sequence of integers with the first five terms as following:

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

`1` is read off as `"one 1"` or `11`.
`11` is read off as `"two 1s"` or `21`.
`21` is read off as `"one 2`, then `one 1"` or `1211`.

Given an integer *n*, generate the *n*th term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

**Example 1:**

```
Input: 1
Output: "1"
```

**Example 2:**

```
Input: 4
Output: "1211"
```
```java
    public String countAndSay(int n) {
        if(n == 1)
            return "1";
        String result = "1";
        for(int i=2;i<=n;i++){
            int idx = 0;
            StringBuilder sb = new StringBuilder();
            while(idx < result.length()){
                char curr = result.charAt(idx);
                int count = 1;
                while(idx<result.length()-1 && result.charAt(idx)==result.charAt(idx+1)){
                    idx ++;
                    count ++;
                }
                sb.append(count).append(curr);
                idx ++;
            }
            result = sb.toString();
        }
        return result;
    }
```

----------

#### 39. Combination Sum (medium)

Given a **set** of candidate numbers (**C**) **(without duplicates)** and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**. 

The **same** repeated number may be chosen from **C** **unlimited number of times**.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[2, 3, 6, 7]` and target `7`, 
A solution set is: 

```
[
  [7],
  [2, 2, 3]
]
```

```java
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // use backtracking
    	List<List<Integer>> result = new ArrayList<>();
        backtrack(result,candidates,new ArrayList<>(),target,0);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] candidates,List<Integer> temp,int target,int idx){
        if(target < 0)
            return;
        if(target == 0){
            // should build a new list
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=idx;i<candidates.length;i++){
            temp.add(candidates[i]);
            // item repeatly used, should call i
            backtrack(result,candidates,temp,target-candidates[i],i);
            // remove after recursion
            temp.remove(temp.size()-1);
        }
    }
```

---------

#### 40. Combination Sum II (medium)

Given a collection of candidate numbers (**C**) and a target number (**T**), find all unique combinations in **C** where the candidate numbers sums to **T**.

Each number in **C** may only be used **once** in the combination.

**Note:**

- All numbers (including target) will be positive integers.
- The solution set must not contain duplicate combinations.

For example, given candidate set `[10, 1, 2, 7, 6, 1, 5]` and target `8`, 
A solution set is: 

```
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

```java
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        // backtracking, duplicate element, use once
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(candidates);    // to skip duplicate
        backtrack(result,candidates,new ArrayList<>(),target,0);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] candidates,List<Integer> temp,int target,int idx){
        if(target < 0)
            return;
        if(target == 0){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=idx;i<candidates.length;i++){
            // here i > idx not 0. to avoid duplicate
            // since same adjacent same element, so need sorting
            if(i>idx && candidates[i]==candidates[i-1])
                continue;
            temp.add(candidates[i]);
            backtrack(result,candidates,temp,target-candidates[i],i+1);
            temp.remove(temp.size()-1);
        }
    }
```

------------

#### 41. First Missing Positive (hard)

Given an unsorted integer array, find the first missing positive integer.

For example,
Given `[1,2,0]` return `3`,
and `[3,4,-1,1]` return `2`.

Your algorithm should run in *O*(*n*) time and uses constant space.

```java
    public int firstMissingPositive(int[] nums) {
        // swap pos num to corresponding index
        for(int i=0;i<nums.length;i++){
            // use nums[i]-1 as index, cannot have cycle
            while(nums[i]>0 && nums[i]<=nums.length && nums[i]!=nums[nums[i]-1]){
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }
        // traverse find nums[i]-1 != i
        for(int i=0;i<nums.length;i++)
            if(nums[i] != i + 1)
                return i + 1;
        // beyond the bound
        return nums.length + 1;
    }
```

---

#### #42-trapping-rain-water-hard

Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example,
Given `[0,1,0,2,1,0,1,3,2,1,2,1]`, return `6`.

![img](http://www.leetcode.com/static/images/problemset/rainwatertrap.png)

The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.

**DP approach O(n) & O(n)** 

```java
    public int trap(int[] height) {
        // use dp 3 pass
        if(height.length == 0)
            return 0;
        // first pass find left max
        int[] left = new int[height.length];
        int leftMax = height[0];
        for(int i=0;i<height.length;i++){
            leftMax = Math.max(leftMax,height[i]);
            left[i] = leftMax;
        }
        // second pass find right max
        int[] right = new int[height.length];
        int rightMax = height[height.length-1];
        for(int i=height.length-1;i>=0;i--){
            rightMax = Math.max(rightMax,height[i]);
            right[i] = rightMax;
        }
        // third pass find water each idx
        int result = 0;
        for(int i=0;i<height.length;i++)
            result += Math.min(left[i],right[i]) - height[i];
        return result;
    }
```

**Stack  approach O(n) & O(n)**

```java
    public int trap(int[] height) {
        // stack approaching
        if(height.length == 0)
            return 0;
        // use stack to save index
        Stack<Integer> stack = new Stack<>();
        int result = 0;
        for(int i=0;i<height.length;i++){
            // if larger than prev
            while(!stack.isEmpty() && height[i]>height[stack.peek()]){
                int currIdx = stack.pop();
                if(stack.isEmpty())
                    break;
                // compare prev height and i height
                int h = Math.min(height[stack.peek()],height[i]) - height[currIdx];
                int w = i - stack.peek() - 1;
                result += h * w;
            }
            stack.push(i);
        }
        return result;
    }
```

**Two pointer approach O(n) & O(1)**

```java
    public int trap(int[] height) {
        // two pointer
        if(height.length == 0)
            return 0;
        // left & right max,
        int left = 0, right = height.length - 1;
        int leftMax = height[left], rightMax = height[right];
        int result = 0;
        // stop when left>right, should be <= 
        while(left <= right){
            // case left ++
            if(leftMax < rightMax){
                if(height[left] < leftMax)
                    result += leftMax - height[left];
                leftMax = Math.max(leftMax,height[left]);
                left ++;
            }else{  // case right --
                if(height[right] < rightMax)
                    result += rightMax - height[right];
                rightMax = Math.max(rightMax,height[right]);
                right --;
            }
        }
        return result;
    }
```

---

#### 43. Multiply Strings (medium)

Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`.

**Note:**

1. The length of both `num1` and `num2` is < 110.
2. Both `num1` and `num2` contains only digits `0-9`.
3. Both `num1` and `num2` does not contain any leading zero.
4. You **must not use any built-in BigInteger library** or **convert the inputs to integer** directly.

```java
    public String multiply(String num1, String num2) {
        if(num1==null || num1.length()==0)
            return "";
        if(num2==null || num2.length()==0)
            return "";
        if(num1.equals("0") || num2.equals("0"))
            return "0";
        int m = num1.length(), n = num2.length();
        // num1 * num2 max len = m + n
        int[] result = new int[m+n];
        // i bit * j bit head is at i+j
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                int n1 = num1.charAt(i) - '0';
                int n2 = num2.charAt(j) - '0';
                int sum = n1 * n2 + result[i+j+1];
                // one digit
                result[i+j+1] = sum % 10;
                // ten digit
                result[i+j] += sum / 10;
            }
        }
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<result.length;i++){
            if(!(sb.length()==0 && result[i]==0))
                sb.append(result[i]);
        }
        return sb.toString();
    }
```

---



#### 44. Wildcard Matching (hard)

Implement wildcard pattern matching with support for `'?'` and `'*'`.

```
'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
```

Similar method to regular expression match, DP approach

```java
    public boolean isMatch(String s, String p) {
        if(s==null || p==null)
            return false;
        boolean[][] dp = new boolean[s.length()+1][p.length()+1];
        dp[0][0] = true;
        // go through first row, * could match ""
        // first col is false, dont match ""
        for(int j=1;j<=p.length();j++)
            if(p.charAt(j-1) == '*')
                dp[0][j] = dp[0][j-1];
        // case 1: p.char==(s.char, ?) => dp[i][j] = dp[i-1][j-1]
        // case 2: p.char==* => * is "" dp[i][j] = dp[i][j-1]
        //                   => * is not "" dp[i][j] = dp[i-1][j];
        for(int i=1;i<=s.length();i++){
            for(int j=1;j<=p.length();j++){
                if(p.charAt(j-1)==s.charAt(i-1) || p.charAt(j-1)=='?')
                    dp[i][j] = dp[i-1][j-1];
                else if(p.charAt(j-1) == '*')
                    // * is sequence and * is blank
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
            }
        }
        return dp[s.length()][p.length()];
    }
```

---

#### 46. Permutations (distinct)(medium)

Given a collection of **distinct** numbers, return all possible permutations.

For example,
`[1,2,3]` have the following permutations:

```
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**Backtracking add to temp**

```java
    public List<List<Integer>> permute(int[] nums) {
        // use backtracking, remember to use visited
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result,nums,new ArrayList<>(),new boolean[nums.length]);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] nums,List<Integer> temp,boolean[] visited){
        if(temp.size() == nums.length){
            result.add(new ArrayList<>(temp));
            return;
        }
        // check visited, i from 0 to n
        for(int i=0;i<nums.length;i++){
            if(visited[i])
                continue;
            visited[i] = true;
            temp.add(nums[i]);
            backtrack(result,nums,temp,visited);
            // reset when return to here
            visited[i] = false;
            temp.remove(temp.size()-1);
        }
    }
```

**Backtracking swap (quicker)**

```java
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result,nums,0);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] nums,int idx){
        if(idx == nums.length){
            List<Integer> temp = new ArrayList<>();
            for(int num: nums)
                temp.add(num);
            result.add(temp);    
            return;
        }
        for(int i=idx;i<nums.length;i++){
            swap(nums,idx,i);
            // swap every position with idx
            backtrack(result,nums,idx+1);
            // swap back when return here
            swap(nums,idx,i);
        }
    }
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

---

#### 47. Permutations II (duplicates)(medium)

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
`[1,1,2]` have the following unique permutations:

```
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

```java
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // need sorting to remove duplicate
        Arrays.sort(nums);
        backtrack(result,nums,new ArrayList<>(),new boolean[nums.length]);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] nums,List<Integer> temp,boolean[] used){
        if(temp.size() == nums.length){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=0;i<nums.length;i++){
            // both !used[i-1] and used[i-1] work
            if(used[i] || i>0&&nums[i]==nums[i-1]&&!used[i-1])
                continue;
            used[i] = true;
            temp.add(nums[i]);
            backtrack(result,nums,temp,used);
            used[i] = false;
            temp.remove(temp.size()-1);
        }
    }
```

---

#### 48. Rotate Image (medium)

Rotate the image by 90 degrees (clockwise).

**Note:**
You have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**clockwise: upside down first, then symmetry**

**anti-clockwise: left right first, then symmetry**

```java
    public void rotate(int[][] matrix) {
        if(matrix.length==0 || matrix[0].length==0)
            return;
        if(matrix.length != matrix[0].length)
            return;
        // upside down
        int n = matrix.length;
        for(int col=0;col<n;col++){
            int up = 0, down = n-1;
            while(up < down){
                int temp = matrix[up][col];
                matrix[up][col] = matrix[down][col];
                matrix[down][col] = temp;
                up ++;
                down --;
            }
        }
        // symmetry
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
```

---

#### 49. Group Anagrams (medium)

Given an array of strings, group anagrams together.

For example, given: `["eat", "tea", "tan", "ate", "nat", "bat"]`, 
Return:

```
[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**Note:** All inputs will be in lower-case.

**HashMap, return**

```java
    public List<List<String>> groupAnagrams(String[] strs) {
        // using hashtable
        // key is sorted str
        List<List<String>> result = new ArrayList<>();
        Map<String,List<String>> map = new HashMap<>();
        if(strs.length == 0)
            return result;
        for(String str: strs){
            char[] c = str.toCharArray();
            Arrays.sort(c);
            String key = new String(c);
            if(!map.containsKey(key))
                map.put(key,new ArrayList<>());
            map.get(key).add(str);            
        }
        // map.keySet() map.values()
        return new ArrayList<>(map.values());
    }
```

---

#### 50. Pow(x,n) (medium) 

**recursion**

```java
    public double myPow(double x, int n) {
        if(n == 0)
            return 1;
        if(n < 0){
            // deal with int.min
            // +2 could remain even or odd
            if(n == Integer.MIN_VALUE)
                n+=2;
            n = -n;
            x = 1 / x;
        }
        if(n % 2 == 0)
            return myPow(x*x,n/2);
        else
            return x * myPow(x*x,n/2);
    }
```

**iteration**

```java
    public double myPow(double x, int n) {
        if(n == 0)
            return 1;
        if(n < 0){
            // deal with int.min
            // +2 could remain even or odd
            if(n == Integer.MIN_VALUE)
                n+=2;
            n = -n;
            x = 1 / x;
        }
        double result = 1;
        while(n > 0){
            if((n & 1) == 1)  // n is odd
                result *= x;
            x *= x;
            n >>= 1;
        }
        return result;
    }
```

---

#### 51. N-Queens (hard)

**backtracking**

The *n*-queens puzzle is the problem of placing *n* queens on an *n*×*n* chessboard such that no two queens attack each other.

![img](https://leetcode.com/static/images/problemset/8-queens.png)

Given an integer *n*, return all distinct solutions to the *n*-queens puzzle.

Each solution contains a distinct board configuration of the *n*-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space respectively.

For example,
There exist two distinct solutions to the 4-queens puzzle:

```
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

```java
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        // construct blank board
        char[][] board = new char[n][n];
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                board[i][j] = '.';
        // backtracking
        backtrack(result,board,0);
        return result; 
    }
    
    private void backtrack(List<List<String>> result,char[][] board,int col){
        if(col == board.length){
            result.add(build(board));
            return;
        }
        // for each row, try each col, only one loop need
        for(int row=0;row<board.length;row++){
            if(isValid(board,row,col)){
                board[row][col] = 'Q';
                backtrack(result,board,col+1);
                board[row][col] = '.';
            }
        }
    }
    
    private boolean isValid(char[][] board,int row,int col){
        int n = board.length;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(board[i][j] == '.')
                    continue;
                // in same row, same col, same diagnal
                if(i==row  || j==col || Math.abs(i-row)==Math.abs(j-col))
                    return false;
            }
        }
        return true;
    }
    
    private List<String> build(char[][] board){
        // build board to a result instance
        int n = board.length;
        List<String> rows = new ArrayList<>();
        for(int i=0;i<n;i++)
            rows.add(String.valueOf(board[i]));
        return rows;
    }
```

---

#### 52. N-Queens II (hard)

Now, instead outputting board configurations, return the total number of distinct solutions.

```java
    public int totalNQueens(int n) {
        // only check valid cases
        // use 4 boolean arrays to mark:
        //     1. traverse each row, no check same row
        //     2. same col occupied
        //     3. 45 diagnal occupied: y=x+b => b=y-x constant
        //     4. 135 diagnal occupied y=-x+b => b=y+x constant
        //         board has 2n-1 diagnals each case
        int[] result = new int[1];
        boolean[] cols = new boolean[n];         // for col
        boolean[] diag1 = new boolean[2*n-1];   // for y-x
        boolean[] diag2 = new boolean[2*n-1];   // for y+x
        backtrack(result,0,cols,diag1,diag2);
        return result[0];        
    }
    private void backtrack(int[] result,int col,boolean[] cols,boolean[] diag1,boolean[] diag2){
        // traverse along rows, 
        int n = cols.length;
        if(col == n){
            result[0]++;
            return;
        }
        for(int row=0;row<n;row++){
            int idx1 = col - row + n - 1; // n-1 offset
            int idx2 = col + row;
            if(cols[row] || diag1[idx1] || diag2[idx2])
                continue;
            cols[row] = true;
            diag1[idx1] = true;
            diag2[idx2] = true;
            backtrack(result,col+1,cols,diag1,diag2);
            cols[row] = false;
            diag1[idx1] = false;
            diag2[idx2] = false;
        }
    }
```

---

#### 53. Maximum subarray (easy)

Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array `[-2,1,-3,4,-1,2,1,-5,4]`,
the contiguous subarray `[4,-1,2,1]` has the largest sum = `6`.

```java
    public int maxSubArray(int[] nums) {
        // save currSum and maxSum 
        int currSum = 0, maxSum = nums[0];
        for(int num: nums){
            currSum = Math.max(num,num+currSum);
            maxSum = Math.max(maxSum,currSum);
        }
        return maxSum;
    }
```

---

#### 54. Spiral Matrix (medium)

Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:

```
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
```

You should return `[1,2,3,6,9,8,7,4,5]`.

![SpiralMatrix](https://leetcode.com/problems/spiral-matrix/Figures/54_spiralmatrix.png)

```java
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if(matrix.length==0 || matrix[0].length==0)
            return result;
        int r1 = 0, r2 = matrix.length-1;
        int c1 = 0, c2 = matrix[0].length-1;
        while(r1<=r2 && c1<=c2){
            // add all r1
            for(int c=c1;c<=c2;c++)
                result.add(matrix[r1][c]);
            // add all c2
            for(int r=r1+1;r<=r2;r++)
                result.add(matrix[r][c2]);
            // if las row or col break
            if(r1==r2 || c1==c2)
                break;
            // add all r2
            for(int c=c2-1;c>=c1+1;c--)
                result.add(matrix[r2][c]);
            // add all c1
            for(int r=r2;r>=r1+1;r--)
                result.add(matrix[r][c1]);
            // update
            r1++;r2--;c1++;c2--;
        }
        return result;
    }
```

---

#### 55. Jump Game (medium)

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position. 

Determine if you are able to reach the last index.

For example:
A = `[2,3,1,1,4]`, return `true`.

A = `[3,2,1,0,4]`, return `false`.

**end to head, check whether it's a good point**

```java
    public boolean canJump(int[] nums) {
        if(nums.length == 0)
            return false;
        // last index that is a good point
        int last = nums.length - 1;
        for(int i=last-1;i>=0;i--){
            if(i + nums[i] >= last)
                last = i;
        }
        return last == 0;
    }
```

---

#### 56. Merge Intervals (medium)

Given a collection of intervals, merge all overlapping intervals.

For example,
Given `[1,3],[2,6],[8,10],[15,18]`,
return `[1,6],[8,10],[15,18]`.

```java
    /**
     * Definition for an interval.
     * public class Interval {
     *     int start;
     *     int end;
     *     Interval() { start = 0; end = 0; }
     *     Interval(int s, int e) { start = s; end = e; }
     * }
     */
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> result = new ArrayList<>();
        if(intervals==null || intervals.size()==0)
            return result;
        Collections.sort(intervals,(o1,o2)->o1.start-o2.start);
        Interval prev = null;
        for(Interval curr : intervals){
            // result blank or no overlapping
            if(prev==null || curr.start>prev.end){
                prev = curr;
                result.add(prev);
            }else   // have overlapping
                prev.end = Math.max(prev.end,curr.end);
        }
        return result;
    }
```

---

#### 57. Insert Interval (hard)

Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

**Example 1:**
Given intervals `[1,3],[6,9]`, insert and merge `[2,5]` in as `[1,5],[6,9]`.

**Example 2:**
Given `[1,2],[3,5],[6,7],[8,10],[12,16]`, insert and merge `[4,9]` in as `[1,2],[3,10],[12,16]`.

This is because the new interval `[4,9]` overlaps with `[3,5],[6,7],[8,10]`.

```java
    /**
     * Definition for an interval.
     * public class Interval {
     *     int start;
     *     int end;
     *     Interval() { start = 0; end = 0; }
     *     Interval(int s, int e) { start = s; end = e; }
     * }
     */
    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> result = new ArrayList<>();
        // assume already sorted
        // Collections.sort(intervals,(o1,o2)->o1.start-o2.start);
        int idx = 0;
        // add intervals before newIntervals first, no overlapping
        while(idx<intervals.size() && intervals.get(idx).end<newInterval.start){
            result.add(intervals.get(idx));
            idx++;
        }
        // merge overlapping intervals, curr.end >= new.start
        while(idx<intervals.size() && intervals.get(idx).start<=newInterval.end){
            Interval curr = intervals.get(idx);
            newInterval.start = Math.min(newInterval.start,curr.start);
            newInterval.end = Math.max(newInterval.end,curr.end);
            idx++;
        }
        result.add(newInterval);
        // add intervals after newIntervals, no overlapping
        while(idx<intervals.size()){
            result.add(intervals.get(idx));
            idx++;
        }
        return result;
    }
```

---

#### 58. Length of Last Word (easy)

Given a string *s* consists of upper/lower-case alphabets and empty space characters `' '`, return the length of last word in the string.

If the last word does not exist, return 0.

**Note:** A word is defined as a character sequence consists of non-space characters only.

**Example:**

```
Input: "Hello World"
Output: 5
```

```java
    public int lengthOfLastWord(String s) {
        int tail = s.length()-1;
        while(tail>=0 && s.charAt(tail)==' ')
            tail--;
        int head = tail;
        while(head>=0 && s.charAt(head)!=' ')
            head--;
        return tail - head;
    }
```

---

#### 59. Spiral Matrix II (medium)

Given an integer *n*, generate a square matrix filled with elements from 1 to *n*2 in spiral order.

For example,
Given *n* = `3`,

You should return the following matrix:

```
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

```java
    public int[][] generateMatrix(int n) {
        int[][] result = new int[n][n];
        int num = 1;
        int r1 = 0, r2 = n - 1;
        int c1 = 0, c2 = n - 1;
        while(r1<=r2 && c1<=c2){
            for(int c=c1;c<=c2;c++)
                result[r1][c] = num++;
            for(int r=r1+1;r<=r2;r++)
                result[r][c2] = num++;
            if(r1==r2 || c1==c2)
                break;
            for(int c=c2-1;c>=c1+1;c--)
                result[r2][c] = num++;
            for(int r=r2;r>=r1+1;r--)
                result[r][c1] = num++;
            r1++;r2--;c1++;c2--;
        }
        return result;
    }
```

---

#### 61. Rotate List (medium)

Given a list, rotate the list to the right by *k* places, where *k* is non-negative.

**Example:**

```
Given 1->2->3->4->5->NULL and k = 2,
return 4->5->1->2->3->NULL.
```

```java
    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) { val = x; }
     * }
     */
    public ListNode rotateRight(ListNode head, int k) {
        // notice corner case
        if(head == null || head.next == null)
            return head;
        ListNode dummy = new ListNode(0), fast = dummy;
        dummy.next = head;
        // find length first, and end node
        int len = 0;
        while(fast.next != null){
            len ++;
            fast = fast.next;
        }
        // find node before new head
        // k may larger than len => %
        ListNode slow = dummy;
        for(int i=0;i<len-k%len;i++)
            slow = slow.next;
        // rotation order, 
        fast.next = dummy.next;
        dummy.next = slow.next;
        slow.next = null;
        return dummy.next;
    }   
```

---

#### 62. Unique Paths (medium)

A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

![img](https://leetcode.com/static/images/problemset/robot_maze.png)

Above is a 3 x 7 grid. How many possible unique paths are there?

**Note:** *m* and *n* will be at most 100.

```java
    public int uniquePaths(int m, int n) {
        // time O(mn), space O(min(m,n))
        if(m <= 0 || n <=0)
            return 0;
        // use 1D dp 
        int[] dp = new int[n];
        Arrays.fill(dp,1);
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
```

---

#### 63. Unique Paths II (medium)

Follow up for "Unique Paths":

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as `1` and `0` respectively in the grid.

For example,

There is one obstacle in the middle of a 3x3 grid as illustrated below.

```
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
```

The total number of unique paths is `2`.

```java
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        // similar to previous, use 1D DP
        if(obstacleGrid==null || obstacleGrid.length==0 || obstacleGrid[0].length==0)
            return 0;
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[] dp = new int[n];
        dp[0] = 1;  // init head as 0
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // obstacle, curr count reset 0
                if(obstacleGrid[i][j] == 1)
                    dp[j] = 0;
                // accumulate when j > 0
                else if(j > 0)
                    dp[j] += dp[j-1];
            }
        }
        return dp[n-1];
    }
```

---

#### 64. Minimum Path Sum (medium)

Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example 1:**

```
[[1,3,1],
 [1,5,1],
 [4,2,1]]
```

Given the above grid map, return 

```
7
```

. Because the path 1→3→1→1→1 minimizes the sum.

```java
    public int minPathSum(int[][] grid) {
        if(grid==null || grid.length==0 || grid[0].length==0)
            return 0;
        int m = grid.length, n = grid[0].length;
        // go through first row
        for(int j=1;j<n;j++)
            grid[0][j] += grid[0][j-1];
        // go through first col
        for(int i=1;i<m;i++)
            grid[i][0] += grid[i-1][0];
        // go through other
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
                grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);
        return grid[m-1][n-1];
    }
```

#### 66. Plus One (easy)

Given a non-negative integer represented as a **non-empty** array of digits, plus one to the integer.

You may assume the integer do not contain any leading zero, except the number 0 itself.

The digits are stored such that the most significant digit is at the head of the list.

```java
    public int[] plusOne(int[] digits) {
        if(digits==null || digits.length==0)
            return new int[0];
        // if 9, continue check previous,
        // if not 9, +1 will stop
        for(int i=digits.length-1;i>=0;i--){
            if(digits[i] == 9)
                digits[i] = 0;
            else{
                digits[i] ++;
                break;
            }
        }
        // if all 0
        if(digits[0] == 0){
            int[] result = new int[digits.length+1];
            result[0] = 1;
            return result;
        }
        return digits;
    }
```

---

#### 67-add-binary-easy

Given two binary strings, return their sum (also a binary string).

For example,
a = `"11"`
b = `"1"`
Return `"100"`.

```java
    public String addBinary(String a, String b) {
        if(a == null || b == null)
            return "";
        // use string builder and reverse
        StringBuilder sb = new StringBuilder();
        int i = a.length() - 1, j = b.length() - 1;
        int sum = 0;
        while(i >= 0 || j >= 0){
            if(i >= 0)
                sum += a.charAt(i--) - '0';
            if(j >= 0)
                sum += b.charAt(j--) - '0';
            sb.append(sum % 2);
            sum /= 2;
        }
        if(sum != 0)
            sb.append(sum);
        return sb.reverse().toString();    
    }
```

----

#### 69. int sqrt(x) (easy)

**binary search**

```java
    public int mySqrt(int x) {
        if(x <= 1)
            return x;
        int left = 1, right = x;
        while(true){
            int mid = left + (right-left)/2;
            if(mid > x / mid)
                right = mid - 1;
            else{
                // mid^2 < x but mid+1 ^2 > x
                if(mid+1 > x/(mid+1))
                    return mid;
                left = mid + 1;
            }
        }
    }
```

---

#### #70-climbing-stairs-easy

You are climbing a stair case. It takes *n* steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note:** Given *n* will be a positive integer.

**Example 1:**

```
Input: 2
Output:  2
Explanation:  There are two ways to climb to the top.

1. 1 step + 1 step
2. 2 steps
```

**Example 2:**

```
Input: 3
Output:  3
Explanation:  There are three ways to climb to the top.

1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

```java
    public int climbStairs(int n) {
        // n step is count n-1 step + count n-2 step
        if(n <= 2)
            return n;
        int first = 1, second = 2, curr = 0;
        for(int i=3;i<=n;i++){
            curr = first + second;
            first = second;
            second = curr;
        }
        return curr;
    }
```

---

#### #71-simplify-path-medium

Given an absolute path for a file (Unix-style), simplify it.

For example,
**path** = `"/home/"`, => `"/home"`
**path** = `"/a/./b/../../c/"`, => `"/c"`

- Did you consider the case where **path** = `"/../"`?
  In this case, you should return `"/"`.
- Another corner case is the path might contain multiple slashes `'/'` together, such as `"/home//foo/"`.
  In this case, you should ignore redundant slashes and return `"/home/foo"`.

```java
    public String simplifyPath(String path) {
        // use stack .. pop else push
        if(path == null || path.length() == 0)
            return "";
        Stack<String> stack = new Stack<>();
        for(String s : path.split("/")){
            // case .(curr folder) continue
            if(s.equals("."))
                continue;
            // case .. prev folder
            else if(s.equals("..")){
                if(!stack.isEmpty())
                    stack.pop();
            // case name dir, not empty, not ///
            }else if(!s.isEmpty()){
                stack.push(s);
            }
        }
        // case /
        if(stack.isEmpty())
            return "/";
        // pop and build result
        StringBuilder sb = new StringBuilder();
        // build list from stack
        List<String> list = new ArrayList<>(stack);
        for(String s : list)
            sb.append("/").append(s);
        return sb.toString();
    }
```

---

#### #72-edit-distance-hard

Given two words *word1* and *word2*, find the minimum number of operations required to convert *word1* to *word2*.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
```

**Example 2:**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

```java
    public int minDistance(String word1, String word2) {
        // similar regex
        if(word1==null || word2==null)
            return 0;
        // row word1, col word2
        int[][] dp = new int[word2.length()+1][word1.length()+1];
        // init first row: word1 to ""
        for(int j=0; j<word1.length(); j++)
            dp[0][j+1] = dp[0][j] + 1;
        // init first col: "" to word2
        for(int i=0; i<word2.length(); i++)
            dp[i+1][0] = dp[i][0] + 1;
        // the other
        for(int i=0; i<word2.length(); i++){
            for(int j=0; j<word1.length(); j++){
                // char1 != char2:
                // 1. insert: dp[i][j] = dp[i-1][j]+1;
                // 2. replace: dp[i][j] = dp[i-1][j-1]+1;
                // 3. delete: dp[i][j] = dp[i][j-1]+1;
                if(word2.charAt(i) != word1.charAt(j)){
                    dp[i+1][j+1] = 1 +
                                   Math.min(dp[i][j],
                                   Math.min(dp[i][j+1],
                                            dp[i+1][j]));
                }else // case char1 == char2
                    dp[i+1][j+1] = dp[i][j];
            }
        }
        return dp[word2.length()][word1.length()];
    }
```



---

#### #73-set-matrix-zeros-medium

Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. Do it in place.

Did you use extra space?
A straight forward solution using O(*m**n*) space is probably a bad idea.
A simple improvement uses O(*m* + *n*) space, but still not the best solution.
Could you devise a constant space solution?

```java
    public void setZeroes(int[][] matrix) {
        // set all leading row & col to zeros
        if(matrix.length==0 || matrix[0].length==0)
            return;
        boolean firstRow = false, firstCol = false;
        int row = matrix.length, col = matrix[0].length;
        // check first col
        for(int i=0;i<row;i++)
            if(matrix[i][0] == 0)
                firstCol = true;
        // check first row
        for(int j=0;j<col;j++)
            if(matrix[0][j] == 0)
                firstRow = true;
        // the other
        for(int i=1;i<row;i++){
            for(int j=1;j<col;j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        // set 0 skip first row & col
        for(int i=1;i<row;i++){
            for(int j=1;j<col;j++){
                if(matrix[i][0]==0 || matrix[0][j]==0)
                    matrix[i][j] = 0;
            }
        }
        // update first row & col can cause problem
        // update first row & col
        if(firstRow)
            for(int j=0;j<col;j++)
                matrix[0][j] = 0;
        if(firstCol)
            for(int i=0;i<row;i++)
                matrix[i][0] = 0;
    }
```

---

#### #74-search-a-2d-matrix-medium

Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

- Integers in each row are sorted from left to right.
- The first integer of each row is greater than the last integer of the previous row.

For example,

Consider the following matrix:

```
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
```

Given **target** = `3`, return `true`.

```java
    public boolean searchMatrix(int[][] matrix, int target) {
        // convert to binary search
        if(matrix==null || matrix.length==0 || matrix[0].length==0)
            return false;
        final int m = matrix.length, n = matrix[0].length;
        // left right should be index
        int left = 0, right = m * n - 1;
        while(left <= right){
            int mid = left + (right-left)/2;
            int row = mid / n;
            int col = mid % n;
            if(matrix[row][col] == target)
                return true;
            else if(matrix[row][col] < target)
                left = mid + 1;
            else
                right = mid - 1;
        }
        return false;
    }
```

---

#### #75-sort-colors-medium

Given an array with *n* objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

**Note:**
You are not suppose to use the library's sort function for this problem.

```java
    public void sortColors(int[] nums) {
        //  0000|i|1111|j|????|k|2222
        if(nums==null || nums.length==0)
            return;
        int i = 0, j = 0, k = nums.length-1;
        // j is unvisited, notice j = k
        while(j <= k){
            if(nums[j] == 0){
                swap(nums,i++,j++);
            }else if(nums[j] == 1)
                j++;
            else if(nums[j] == 2)
                swap(nums,j,k--);
        }
    }
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

```java
    public void sortColors(int[] nums) {
        //  0000|i|1111|j|????|k|2222
        if(nums==null || nums.length==0)
            return;
        int i = 0, j = 0, k = nums.length-1;
        // j is unvisited, notice j = k
        while(j <= k){
            if(nums[j] == 0){
                nums[j++] = nums[i];
                nums[i++] = 0;
            }else if(nums[j] == 1){
                j ++;
            }else if(nums[j] == 2){
                nums[j] = nums[k];
                nums[k--] = 2;
            }
        }
    }
```

---

#### #76-minimun-window-substring-hard

Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

For example,
**S** = `"ADOBECODEBANC"`
**T** = `"ABC"`

Minimum window is `"BANC"`.

**Note:**
If there is no such window in S that covers all characters in T, return the empty string `""`.

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.

```java
    public String minWindow(String s, String t) {
        if(s==null || t==null)
            return "";
        // find t histogram first
        int[] bin = new int[256];
        for(char c : t.toCharArray())
            bin[c] ++;
        // sliding window
        int head = 0, count = t.length();
        int minLen = s.length() + 1, minHead = 0;
        for(int tail=0;tail<s.length();tail++){
            if(bin[s.charAt(tail)] > 0)
                count --;
            bin[s.charAt(tail)]--;
            // valid edge condition
            while(count == 0){
                // update min then shift window
                if(tail-head+1 < minLen){
                    minLen = tail - head + 1;
                    minHead = head;
                }
                if(bin[s.charAt(head)] == 0)
                    count ++;
                bin[s.charAt(head)]++;
                head++;
            }
        }
        return minLen > s.length() ? "" : s.substring(minHead,minHead+minLen);
    }
```

---

#### #77-combinations-medium

Given two integers *n* and *k*, return all possible combinations of *k* numbers out of 1 ... *n*.

For example,
If *n* = 4 and *k* = 2, a solution is:

```
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
    public List<List<Integer>> combine(int n, int k) {
        // backtracking
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result,new ArrayList<>(),1,n,k);
        return result;
    }
    private void backtrack(List<List<Integer>> result,List<Integer> temp,int start,int end,int count){
        // optimization here, if start to close to end so no enough elements
        if(count - temp.size() > end - start + 1)
            return;
        //////////////////////////////////////
        if(temp.size() == count){
            result.add(new ArrayList<>(temp));
            return;
        }
        for(int i=start;i<=end;i++){
            temp.add(i);
            backtrack(result,temp,i+1,end,count);
            temp.remove(temp.size()-1);
        }
    }
```

---

#### #78-subsets-medium

Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

For example,
If **nums** = `[1,2,3]`, a solution is:

```
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```java
    public List<List<Integer>> subsets(int[] nums) {
        // backtracking // distinct
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result,nums,new ArrayList<>(),0);
        return result;
    }
    private void backtrack(List<List<Integer>> result, int[] nums,List<Integer> temp,int idx){
        // add result each level
        result.add(new ArrayList<>(temp));
        for(int i=idx;i<nums.length;i++){
            temp.add(nums[i]);
            backtrack(result,nums,temp,i+1);
            temp.remove(temp.size()-1);
        }
    }
```

---

#### #79-word-search-medium

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given **board** = 

```
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
```

word = `"ABCCED"`, -> returns `true`,

word = `"SEE"`, -> returns `true`,

word = `"ABCB"`, -> returns `false`.

```java
    public boolean exist(char[][] board, String word) {
        // similar to num of island
        // use ^256 to obtain space O(1)
        if(board==null || board.length==0 || board[0].length==0)
            return false;
        final int m = board.length, n = board[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(helper(board,word,0,i,j))
                    return true;
            }
        }
        return false;
    }
    private boolean helper(char[][] board,String word,int idx,int x,int y){
        if(idx == word.length())
            return true;
        if(x<0 || x>=board.length || y<0 || y>=board[0].length || 
           word.charAt(idx)!=board[x][y])
            return false;
        // set to not a valid letter
        board[x][y] ^= 256;
        if(helper(board,word,idx+1,x-1,y) ||
          helper(board,word,idx+1,x+1,y) ||
          helper(board,word,idx+1,x,y-1) ||
          helper(board,word,idx+1,x,y+1))
            return true;
        // reset to letter
        board[x][y] ^= 256;
        return false;
    }
```

---

#### #80-remove-duplicates-from-sorted-array-ii-medium

Follow up for "Remove Duplicates":
What if duplicates are allowed at most *twice*?

For example,
Given sorted array *nums* = `[1,1,1,2,2,3]`,

Your function should return length = `5`, with the first five elements of *nums* being `1`, `1`, `2`, `2` and `3`. It doesn't matter what you leave beyond the new length.

```java
    public int removeDuplicates(int[] nums) {
        if(nums==null)
            return 0;
        if(nums.length <= 2)
            return nums.length;
        int tail = 2;
        // similar but check tail - 2
        for(int i=2;i<nums.length;i++){
            if(nums[i] != nums[tail-2])
                nums[tail++] = nums[i];
        }
        return tail;
    }
    public int removeDuplicates(int[] nums) {
        // optimized
        if(nums==null)
            return 0;
        if(nums.length <= 2)
            return nums.length;
        int tail = 0;
        for(int num : nums){
            if(tail < 2 || num != nums[tail-2])
                nums[tail++] = num;
        }
        return tail;
    }
```

---

#### #81-search-in-rotated-sorted-array-ii-medium

> *Follow up* for "Search in Rotated Sorted Array":
> What if *duplicates* are allowed?
>
> Would this affect the run-time complexity? How and why?

[#33-search-in-rotated-sorted-array-medium](#33-search-in-rotated-sorted-array-medium)

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `0 1 2 4 5 6 7` might become `4 5 6 7 0 1 2`).

Write a function to determine if a given target is in the array.

The array may contain duplicates.

```java
    public boolean search(int[] nums, int target) {
// 1) everytime check if targe == nums[mid], if so, we find it.
// 2) otherwise, we check if the first half is in order (i.e. nums[left]<=nums[mid]) 
//   and if so, go to step 3), otherwise, the second half is in order,   go to step 4)
// 3) check if target in the range of [left, mid-1] (i.e. nums[left]<=target < nums[mid]), 
//         if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;
// 4)  check if target in the range of [mid+1, right] (i.e. nums[mid]<target <= nums[right]), 
//         if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;
        if(nums==null || nums.length==0)
            return false;
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right-left)/2;
            if(nums[mid] == target)
                return true;
            // difference to deal with duplicate here
            if(nums[left]==nums[mid] && nums[mid]==nums[right]){
            left++;
            right--;
            // left half not rotate
            }else if(nums[left] <= nums[mid]){
                // mid in not rotate part
                if(nums[left]<=target && target<nums[mid])
                    right = mid - 1;
                // mid in rotate part
                else left = mid + 1;
            // right half not rotate
            }else if(nums[mid] <= nums[right]){
                // mid in not rotate part
                if(nums[mid]<target && target<=nums[right])
                    left = mid + 1;
                // mid in rotate part
                else right = mid -1;
            }
        }
        return false;       
    }
```

---

#### #82-remove-duplicates-from-sorted-list-ii-medium

Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only *distinct* numbers from the original list.

For example,
Given `1->2->3->3->4->4->5`, return `1->2->5`.
Given `1->1->1->2->3`, return `2->3`.

```java
    /**
     * Definition for singly-linked list.
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode(int x) { val = x; }
     * }
     */
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null)
            return head;
        ListNode dummy = new ListNode(0);
        ListNode prev = dummy, curr = head;
        dummy.next = head;
        while(curr != null){
            // if next val = curr val, check next
            while(curr.next!=null && curr.val==curr.next.val)
                curr = curr.next;
            // if curr is distinct
            if(prev.next == curr)
                prev = prev.next;
            else    
            // prev stays, case next sequence duplication
            // curr is the last duplication
                prev.next = curr.next;   
            curr = curr.next;
            
        }
        return dummy.next;
    }
```

---

#### #83-remove-duplicates-from-sorted-list-easy

Given a sorted linked list, delete all duplicates such that each element appear only *once*.

For example,
Given `1->1->2`, return `1->2`.
Given `1->1->2->3->3`, return `1->2->3`.

**iteration**

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null)
            return head;
        ListNode curr = head;
        while(curr != null){
            while(curr.next!=null && curr.val==curr.next.val)
                curr.next = curr.next.next;
            curr = curr.next;
        }
        return head;
    }
```

**recursion**

```java
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null)
            return head;
        head.next = deleteDuplicates(head.next);
        // here head.next != null
        return head.val == head.next.val ? head.next : head;
    }
```

---

#### #84-largest-rectangle-in-histogram-hard

Given *n* non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

![img](https://leetcode.com/static/images/problemset/histogram.png)

Above is a histogram where width of each bar is 1, given height = `[2,1,5,6,2,3]`.

![img](https://leetcode.com/static/images/problemset/histogram_area.png)

The largest rectangle is shown in the shaded area, which has area = `10` unit.

For example,
Given heights = `[2,1,5,6,2,3]`,
return `10`.

[#42-trapping-rain-water-hard](#42-trapping-rain-water-hard)

```java
	// Maintains an increasing stack
	// encounter smaller height, check all previous areas.
	public int largestRectangleArea(int[] heights) {
		Stack<Integer> idxStack = new Stack<>();
		int maxArea = 0;
		for (int i = 0; i <= heights.length; i++) {
			// push -1 for last, to pop all previous
			int height = i == heights.length ? 0 : heights[i];
			// when increasing is broken
			while (!idxStack.isEmpty() && heights[idxStack.peek()] >= height) {
				// get previous higher one, compute previous area
				// it's all area from smaller to the highest
				int h = heights[idxStack.pop()];
				// if is empty, there is a bottom rectangle from current to head
				int w = idxStack.isEmpty() ? i : i - 1 - idxStack.peek();
				maxArea = Math.max(maxArea, h * w);
			}
			idxStack.push(i);
		}
		return maxArea;
	}
```

**optimized beats 98%, check left then right idea **

```java
    public int largestRectangleArea(int[] heights) {
        // save left and right index
        // width is most left & right idx whose h is larger
        if(heights==null || heights.length==0)
            return 0;
        int[] left = new int[heights.length];
        int[] right = new int[heights.length];
        // find left/right index whose h is larger
        // utilize previous result to reduce run time
        for(int i=0;i<heights.length;i++){
            int l = i-1;
            while(l>=0 && heights[l]>=heights[i])
                l = left[l];
            left[i] = l;
        }
        for(int i=heights.length-1;i>=0;i--){
            int r = i+1;
            while(r<heights.length && heights[r]>=heights[i])
                r = right[r];
            right[i] = r;
        }        
        // then for h, the width is r - l - 1;
        int maxArea = 0;
        for(int i=0;i<heights.length;i++){
            int w = right[i] - left[i] - 1;
            maxArea = Math.max(maxArea,heights[i]*w);
        }
        return maxArea;
    }
```

---



---

#### #86-partition-list-medium

Given a linked list and a value *x*, partition it such that all nodes less than *x* come before nodes greater than or equal to *x*.

You should preserve the original relative order of the nodes in each of the two partitions.

**Example:**

```
Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5
```

```java
    public ListNode partition(ListNode head, int x) {
        // use two head;
        ListNode dummy1 = new ListNode(0), prev1 = dummy1;
        ListNode dummy2 = new ListNode(0), prev2 = dummy2;
        while(head != null){
            if(head.val < x){
                prev1.next = head;
                prev1 = prev1.next;
            }else{
                prev2.next = head;
                prev2 = prev2.next;
            }
            head = head.next;
        }
        // combine two list
        prev1.next = dummy2.next;
        prev2.next = null;
        return dummy1.next;
    }
```

---

#### #87-scramble-string-hard

Given a string *s1*, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of *s1* = `"great"`:

```
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
```

To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node `"gr"` and swap its two children, it produces a scrambled string `"rgeat"`.

```
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
```

We say that `"rgeat"` is a scrambled string of `"great"`.

Similarly, if we continue to swap the children of nodes `"eat"` and `"at"`, it produces a scrambled string `"rgtae"`.

```
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
```

We say that `"rgtae"` is a scrambled string of `"great"`.

Given two strings *s1* and *s2* of the same length, determine if *s2* is a scrambled string of *s1*.

**Example 1:**

```
Input: s1 = "great", s2 = "rgeat"
Output: true
```

**Example 2:**

```
Input: s1 = "abcde", s2 = "caebd"
Output: false
```

```java
    public boolean isScramble(String s1, String s2) {
        // check all possible case
        if(s1.equals(s2))
            return true;
        // check char count
        int[] bin = new int[256];
        for(int i=0; i<s1.length(); i++){
            bin[s1.charAt(i)]++;
            bin[s2.charAt(i)]--;
        }
        // check is char equal
        for(int n : bin)
            if(n != 0)
                return false;
        // recursion call, check all substring
        // origin not include, from 1 to length
        for(int i=1; i<s1.length(); i++){
            // a b | c d e, a b | d e c
            if(isScramble(s1.substring(0,i),s2.substring(0,i)) 
               && isScramble(s1.substring(i),s2.substring(i)))
                return true;
            // a b | c d e, c d e | a b
            if(isScramble(s1.substring(0,i),s2.substring(s2.length()-i)) 
               && isScramble(s1.substring(i),s2.substring(0,s2.length()-i)))
                return true;
        }
        return false;
    }
```

---

#### #88-merge-sorted-array-easy

Given two sorted integer arrays *nums1* and *nums2*, merge *nums2* into *nums1* as one sorted array.

**Note:**

- The number of elements initialized in *nums1* and *nums2* are *m* and *n* respectively.
- You may assume that *nums1* has enough space (size that is greater or equal to *m* + *n*) to hold additional elements from *nums2*.

**Example:**

```
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```

```java
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // from end to head,
        int i = m - 1, j = n - 1, k = m + n - 1;
        while(i >= 0 && j >= 0)
            nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
        while(j >= 0)  // nums2 rest
            nums1[k--] = nums2[j--];
    }
```

---

#### #89-gray-code-medium

The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer *n* representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given *n* = 2, return `[0,1,3,2]`. Its gray code sequence is:

```
00 - 0
01 - 1
11 - 3
10 - 2
```

**Note:**
For a given *n*, a gray code sequence is not uniquely defined.

For example, `[0,2,3,1]` is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

```java
    public List<Integer> grayCode(int n) {
        // bit manipulate
        List<Integer> result = new ArrayList();
        // total should < 1 << n
        for(int i=0; i < 1<<n; i++){
            result.add(i ^ i>>1);
        }
        return result;
    }
```

---

#### #90-subsets-ii-medium

Given a collection of integers that might contain duplicates, **nums**, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

**Example:**

```
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```

```java
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        // since remove duplicate, need sorting
        Arrays.sort(nums);
        backtrack(result,nums,new ArrayList<>(),0);
        return result;
    }
    private void backtrack(List<List<Integer>> result,int[] nums,List<Integer> temp,int idx){
        // no need to check
        result.add(new ArrayList<>(temp));
        for(int i=idx;i<nums.length;i++){
            // jump duplicate
            // notice its > idx not > 0
            if(i>idx && nums[i]==nums[i-1])
                continue;
            temp.add(nums[i]);
            backtrack(result,nums,temp,i+1);
            temp.remove(temp.size()-1);
        }
    }
```

---





---

#### #92-reverse-linked-list-ii-medium

Reverse a linked list from position *m* to *n*. Do it in one-pass.

**Note:** 1 ≤ *m* ≤ *n* ≤ length of list.

**Example:**

```
Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL
```

```java
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy = new ListNode(0);
        ListNode start = dummy;
        dummy.next = head;
        // find slow prev first
        for(int i=1; i<m; i++)
            start = start.next;
        // end not change, curr for saving
        ListNode end = start.next, curr = null;
        for(int i=0; i<n-m; i++){
            curr = end.next;
            end.next = curr.next;
            curr.next = start.next;
            start.next = curr;
        }
        return dummy.next;
    }
```

---

#### #93-restore-ip-addresses-medium

Given a string containing only digits, restore it by returning all possible valid IP address combinations.

**Example:**

```
Input: "25525511135"
Output: ["255.255.11.135", "255.255.111.35"]
```

```java
    public List<String> restoreIpAddresses(String s) {
        List<String> result = new ArrayList<>();
        backtrack(result,s,new StringBuilder(),0,1);
        return result;
    }
    private void backtrack(List<String> result,String s,StringBuilder sb,int idx,int block){
        // to 5 block and s is empty
        if(block == 5 && idx == s.length()){
            result.add(sb.toString());
            return;
        }
        // s left or block left
        if(block > 4 || idx == s.length())
            return;
        int len = sb.length(); // for reset
        // one block most 3 digit
        for(int i=1; i<4 && idx+i<=s.length(); i++){
            String partition = s.substring(idx,idx+i);
            // case 001 && 256
            if(i!=1 && partition.charAt(0)=='0' ||
              i==3 && Integer.parseInt(partition)>255)
                continue;
            sb.append(partition);
            // for seperator
            if(block < 4)
                sb.append('.');
            // backtrack
            backtrack(result,s,sb,idx+i,block+1);
            sb.setLength(len);
        }
    }
```

---

#### #94-binary-tree-inorder-traversal-medium

**Recursion:**

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        dfs(root,result);
        return result;
    }
    private void dfs(TreeNode root,List<Integer> result){
        if(root == null)
            return;
        dfs(root.left,result);
        result.add(root.val);
        dfs(root.right,result);
    }
```

**Iteration:**

```java
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root!=null){
            if(root != null){
                stack.push(root);
                root = root.left;
            }else{
                TreeNode curr = stack.pop();
                result.add(curr.val);
                root = curr.right;
            }
        }
        return result;
    }
```

---



---

#### #97-interleaving-string-hard

Given *s1*, *s2*, *s3*, find whether *s3* is formed by the interleaving of *s1* and *s2*.

**Example 1:**

```
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
```

**Example 2:**

```
Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
```

```java
    public boolean isInterleave(String s1, String s2, String s3) {
        if(s1==null || s2==null || s3==null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
        // s2 row, s1 col
        boolean[][] dp = new boolean[s1.length()+1][s2.length()+1];
        dp[0][0] = true; // "" + "" == ""
        // init first row: check j-1 && char==char for s2
        for(int j=0; j<s2.length(); j++)
            dp[0][j+1] = dp[0][j] && s2.charAt(j)==s3.charAt(j);
        // init first col: check i-1 && char==char for s1
        for(int i=0; i<s1.length(); i++)
            dp[i+1][0] = dp[i][0] && s1.charAt(i)==s3.charAt(i);
        // dp
        for(int i=0; i<s1.length(); i++){
            for(int j=0; j<s2.length(); j++){
                // case1, add s1.char at tail
                // [i-1][j] && s1.char==s3.char
                // case2, add s2.char at tail
                // [i][j-1] && s2.char==s3.char
                char c1 = s1.charAt(i);
                char c2 = s2.charAt(j);
                char c3 = s3.charAt(i+j+1); // notice +1
                // use if will quicker
                dp[i+1][j+1] = (dp[i][j+1] && c1==c3) ||
                               (dp[i+1][j] && c2==c3);
            }
        }
        return dp[s1.length()][s2.length()];
    }
```

---

#### #98-validate-binary-search-tree-medium

Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

```java
    public boolean isValidBST(TreeNode root) {
        // inorder iteration
        Stack<TreeNode> stack = new Stack<>();
        TreeNode prev = null;
        while(!stack.isEmpty() || root!=null){
            if(root != null){
                stack.push(root);
                root = root.left;
            }else{
                TreeNode curr = stack.pop();
                // do inorder here
                if(prev==null || prev.val<curr.val)
                    prev = curr;    // valid, mush < 
                else
                    return false;
                root = curr.right;
            }
        }
        return true;
    }
```

---



---

#### #100-same-tree-easy

```java
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null)
            return true;
        if(p==null || q==null)
            return false;
        if(p.val == q.val)
            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
        return false;
    }
```

---

#### #101-symmetric-tree-easy

**recursion:**

```java
    public boolean isSymmetric(TreeNode root) {
        return root == null || isSymmetric(root.left,root.right);        
    }
    private boolean isSymmetric(TreeNode left,TreeNode right){
        if(left == null && right == null)
            return true;
        if(left == null || right == null)
            return false;
        if(left.val == right.val)
            return isSymmetric(left.left,right.right) &&
                    isSymmetric(left.right,right.left);
        return false;
    }
```

**iteration:**

```java
    public boolean isSymmetric(TreeNode root) {
        if(root == null)
            return true;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);
        while(queue.size() >= 2){
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            if(left==null && right==null)
                continue;
            if(left==null || right==null)
                return false;
            if(left.val != right.val)
                return false;
            queue.add(left.left);
            queue.add(right.right);
            queue.add(left.right);
            queue.add(right.left);
        }
        return true;
    }
```

---

#### #102-level-order-traversal-medium

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null)
            return result;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new ArrayList<>(size);
            result.add(level);
            for(int i=0; i<size; i++){
                TreeNode curr = queue.poll();
                level.add(curr.val);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);
            }
        }
        return result;
    }
```

**Level order II**

```java
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        if(root == null)
            return result;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new ArrayList<>(size);
            result.add(0,level);
            for(int i=0; i<size; i++){
                TreeNode curr = queue.poll();
                level.add(curr.val);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);
            }
        }
        return result;
    }
```





---

#### #103-zigzag-level-order-traversal-medium

Given a binary tree, return the *zigzag level order* traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

return its zigzag level order traversal as:

```
[
  [3],
  [20,9],
  [15,7]
]
```

```java
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root == null)
            return result;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int cnt = 0;
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new LinkedList<>();
            result.add(level);
            for(int i=0; i<size; i++){
                TreeNode curr = queue.poll();
                if(cnt % 2 == 0)
                    level.add(curr.val);
                else
                    level.add(0,curr.val);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);
            }
            cnt ++;
        }
        return result;
    }
```

---



---

#### #105-construct-tree-preorder-inorder-medium

Given preorder and inorder traversal of a tree, construct the binary tree.

**Note:**
You may assume that duplicates do not exist in the tree.

For example, given

```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```

Return the following binary tree:

```
    3
   / \
  9  20
    /  \
   15   7
```

```java
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // use preorder traverse root, inorder find left & right
        return helper(preorder,inorder,0,0,inorder.length-1);
    }
    private TreeNode helper(int[] preorder,int[] inorder,int preTail,int inHead,int inTail){
        if(inHead > inTail || preTail==preorder.length)
            return null;
        TreeNode node = new TreeNode(preorder[preTail]);
        // search node in inorder
        int idx = 0;
        for(int i=inHead; i<=inTail; i++){
            if(inorder[i] == node.val)
                idx = i;
        }
        // [inHead, i-1] left part, [i+1,inTail] right part
        int leftNode = preTail + 1;
        int rightNode = preTail + 1 + idx - inHead;
        node.left = helper(preorder,inorder,leftNode,inHead,idx-1);
        node.right = helper(preorder,inorder,rightNode,idx+1,inTail);
        return node;
    }
```

---

#### #106-construct-tree-inorder-postorder-medium

Given inorder and postorder traversal of a tree, construct the binary tree.

**Note:**
You may assume that duplicates do not exist in the tree.

For example, given

```
inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
```

Return the following binary tree:

```
    3
   / \
  9  20
    /  \
   15   7
```

```java
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        // from postorder define root, left child,
        // from inorder define left half, right half
        return helper(inorder, postorder, 0, inorder.length-1, 0, postorder.length-1);
    }
    private TreeNode helper(int[] inorder, int[] postorder, int inHead, int inTail, int postHead, int postTail){
        // postHead,postTail not matter
        if(inHead > inTail || postHead > postTail)
            return null;
        // use postTail define root
        TreeNode node = new TreeNode(postorder[postTail]);
        // define left half and right half, search in inorder
        int idx = 0;
        for(int i=inHead; i<=inTail; i++)
            if(inorder[i] == node.val){
                idx = i;
                break;
            }
        // define left child and right child
        int leftNode = postHead + (idx - inHead - 1);
        int rightNode = leftNode + 1;
        node.left = helper(inorder,postorder,inHead,idx-1,postHead,leftNode);
        node.right = helper(inorder,postorder,idx+1,inTail,rightNode,postTail-1);
        return node;
    }
```

---



---

#### #109-sorted-list-to-bst-medium

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.

**Example:**

```
Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
    public TreeNode sortedListToBST(ListNode head) {
        if(head == null)
            return null;
        // from here see tail init null, exclude
        return helper(head,null);
    }
    private TreeNode helper(ListNode head,ListNode tail){
        // tail exclude
        if(head == tail)
            return null;
        ListNode slow = head, fast = head;
        // find mid when fast reach tail
        while(fast != tail && fast.next != tail){
            slow = slow.next;
            fast = fast.next.next;
        }
        // mid is slow
        TreeNode node = new TreeNode(slow.val);
        node.left = helper(head,slow);// mid exclude
        node.right = helper(slow.next,tail);
        return node;
    }
```

---





---

#### #110-balanced-binary-tree-easy

```java
    public boolean isBalanced(TreeNode root) {
        if(root == null)
            return true;
        int left = depth(root.left);
        int right = depth(root.right);
        if(Math.abs(left - right) > 1)
            return false;
        return isBalanced(root.left) && isBalanced(root.right);
    }
    private int depth(TreeNode root){
        return root == null ? 0 :
              1 + Math.max(depth(root.left),depth(root.right));
    }
```

---

#### #111-min-depth-of-binary-tree-easy

```java
    public int minDepth(TreeNode root) {
        if(root == null)
            return 0;
        int left = minDepth(root.left);
        int right = minDepth(root.right);
        if(left == 0 || right == 0)
            return left + right + 1;
        else
            return Math.min(left,right) + 1;
    }
```

---

#### #112-path-sum-easy

Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

```java
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return false;
        // when leaf node
        if(root.left==null && root.right==null && root.val==sum)
            return true;
        return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum-root.val);
    }
```

---

#### #113-path-sum-ii-medium

Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

```java
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<>();
        helper(root,sum,result,new ArrayList<>());
        return result;
    }
    private void helper(TreeNode root,int sum,List<List<Integer>> result,List<Integer> temp){
        if(root == null)
            return;
        // add here, add when null=>duplicate result
        temp.add(root.val);
        // valid result added
        if(root.left==null && root.right==null && root.val==sum)
            result.add(new ArrayList<>(temp));
        // left and right
        helper(root.left,sum-root.val,result,temp);
        helper(root.right,sum-root.val,result,temp);
        // remove curr
        temp.remove(temp.size()-1);
    }
```

---

#### #114-flatten-binary-tree-to-linked-list-medium

Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

```
    1
   / \
  2   5
 / \   \
3   4   6
```

The flattened tree should look like:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

```java
class Solution {
    TreeNode prev = null;
    public void flatten(TreeNode root) {
        if(root == null)
            return;
        // use reverse post order
        flatten(root.right);
        flatten(root.left);
        root.right = prev;
        root.left = null;
        prev = root;
    }
}
```

---



---

#### #115-distinct-subsequences-hard

Given a string **S** and a string **T**, count the number of distinct subsequences of **S** which equals **T**.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `"ACE"` is a subsequence of `"ABCDE"` while `"AEC"` is not).

**Example 1:**

```
Input: S = "rabbbit", T = "rabbit"
Output: 3
Explanation:

As shown below, there are 3 ways you can generate "rabbit" from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

```java
    public int numDistinct(String s, String t) {
        // similar to regex 10
        // use dp
        if(s==null || t==null)
            return 0;
        // rows t, columns s, remove char from s
        int[][] dp = new int[t.length()+1][s.length()+1];
        // init first row: remove all to get ""
        for(int col=0; col<=s.length(); col++)
            dp[0][col] = 1;
        // init first col: should all be 0: "" cannot get un-""
        for(int i=0; i<t.length(); i++){    // for t
            for(int j=0; j<s.length(); j++){ // for s
                // 1. if same char: keep it || remove it
                // if keep dp[i][j] = dp[i-1][j-1];
                // if remove dp[i][j] = dp[i][j-1];
                if(s.charAt(j) == t.charAt(i)){
                    dp[i+1][j+1] = dp[i][j] + dp[i+1][j];
                }else{  // 2. if not same: remove it
                    dp[i+1][j+1] = dp[i+1][j];
                }
            }
        }
        return dp[t.length()][s.length()];        
    }
```

---

#### #116-populating-next-right-pointer-medium

Given a binary tree

```
struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

After calling your function, the tree should look like:

```
     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
```

```java
    public void connect(TreeLinkNode root) {
        if(root == null)
            return;
        TreeLinkNode level = root, curr = null;
        while(level != null){
            curr = level;
            while(curr != null){
                if(curr.left != null){
                    curr.left.next = curr.right;
                    if(curr.next != null)
                        curr.right.next = curr.next.left;
                }
                curr = curr.next;
            }
            level = level.left;
        }
    }
```



---

---

#### #120-triangle-medium

Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

The minimum path sum from top to bottom is `11` (i.e., 2 + 3 + 5 + 1 = 11).

**Note:**
Bonus point if you are able to do this using only *O*(*n*) extra space, where *n* is the total number of rows in the triangle.

```java
    public int minimumTotal(List<List<Integer>> triangle) {
        // add bottom up, so that space O(1)
        if(triangle.size() == 0)
            return 0;
        int n = triangle.size();
        // n+1 for the last line
        int[] memo = new int[n+1];
        // for location i, check i & i+1
        for(int i=n-1; i>=0; i--){
            for(int j=0; j<triangle.get(i).size(); j++){
                int curr = triangle.get(i).get(j);
                // memo is init as 0s
                memo[j] = Math.min(memo[j],memo[j+1]) + curr;
            }
        }
        return memo[0];
    }
```

---

#### #130-surrounded-regions

Given a 2D board containing `'X'` and `'O'` (the **letter** O), capture all regions surrounded by `'X'`.

A region is captured by flipping all `'O'`s into `'X'`s in that surrounded region.

For example,

```
X X X X
X O O X
X X O X
X O X X
```

After running your function, the board should be:

```
X X X X
X X X X
X X X X
X O X X
```

**Notice overflow case: **

```
OOOOOOOOOO
XXXXXXXXXO
OOOOOOOOOO
OXXXXXXXXX
OOOOOOOOOO
XXXXXXXXXO
OOOOOOOOOO
OXXXXXXXXX
OOOOOOOOOO
XXXXXXXXXO
```

```
OOOOOOOOOOOX
XXXXXXXXXXOX
XOOOOOOOOOOX
XOXXXXXXXXXX
XOOOOOOOOOOX
XXXXXXXXXXOX
XOOOOOOOOOOX
XOXXXXXXXXXX
XOOOOOOOOOOX
XXXXXXXXXXOX
```

```java
    public void solve(char[][] board) {
        // if surrounded, must at edge
        // check edge set 0 to 1
        if(board==null||board.length==0||board[0].length==0)
            return;
        int m = board.length, n = board[0].length;
        // set first last row
        for(int j=0; j<n; j++){
            check(board,m,n,0,j);
            if(m > 1)
                check(board,m,n,m-1,j);
        }
        // set left right col
        for(int i=1; i<m; i++){
            check(board,m,n,i,0);
            if(n > 1)
                check(board,m,n,i,n-1);
        }
        // set 1 to 0, 0 to X
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(board[i][j] == '1')
                    board[i][j] = 'O';
                else if(board[i][j] == 'O')
                    board[i][j] = 'X';
            }
        }
    }
    private void check(char[][] board,int m,int n,int i,int j){
        // use trick avoid TLE, skip first row and left col
        // skip only one not both for best performance
        if(board[i][j] == 'O'){
            board[i][j] = '1';
            // use i>1 instead of i>=1
            if(i > 1)
                check(board,m,n,i-1,j);
            if(i < m-1)
            	check(board,m,n,i+1,j);
            // use j>1 instead of j>=1
            if(j > 1)
                check(board,m,n,i,j-1);
            if(j < n-1)
                check(board,m,n,i,j+1);
        }
    }
```

---

#### #133-clone-graph-medium

Clone an undirected graph. Each node in the graph contains a `label` and a list of its `neighbors`.

```java
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        Map<Integer,UndirectedGraphNode> visited = new HashMap<>();
        return clone(node,visited);
    }
    private UndirectedGraphNode clone(UndirectedGraphNode node, Map<Integer,UndirectedGraphNode> visited){
        if(node == null)
            return null;
        if(visited.containsKey(node.label))
            return visited.get(node.label);
        UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);
        visited.put(node.label,newNode);
        for(UndirectedGraphNode n : node.neighbors){
            newNode.neighbors.add(clone(n,visited));
        }
        return newNode;
    }
```

---



---

#### #136-single-number-easy

Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.

```java
    public int singleNumber(int[] nums) {
        int result = 0;
        for(int num : nums)
            result ^= num;
        return result;
    }
```

---





---

#### #146-lru-cache-hard

Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
`put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

**Follow up:**
Could you do both operations in **O(1)** time complexity?

**Example:**

```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

```java
class LRUCache {
    // implement double linked list
    // most recent at head
    // least recent at tail
    DListNode head = null;
    DListNode tail = null;
    int capacity = 0;
    Map<Integer,DListNode> map; // save key, node
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        // init head tail
        head = new DListNode();
        tail = new DListNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if(!map.containsKey(key))
            return -1;
        DListNode node = map.get(key);
        moveToHead(node);   // most recent
        return node.val;
    }
    
    public void put(int key, int value) {
        // notice when same key, diff val
        if(map.containsKey(key)){
            DListNode node = map.get(key);
            node.setVal(value);
            moveToHead(node);   // active
            return;
        }
        DListNode node = new DListNode(key,value);
        if(capacity == 0){
            int removeKey = removeLast();
            // remove least from list and map
            map.remove(removeKey);
            capacity ++;
        }
        addFirst(node);
        map.put(key,node);
        capacity --;
    }
    // add most recent to head    
    private void addFirst(DListNode node){
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    // remove a node
    private void remove(DListNode node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
        node.prev = null;
        node.next = null;            
    }
    // remove least recent node, return key
    private int removeLast(){
        DListNode last = tail.prev;
        remove(tail.prev);
        return last.key;
    }
    // set to head
    private void moveToHead(DListNode node){
        remove(node);
        addFirst(node);
    }
    
    private class DListNode{
        int key;
        int val;
        DListNode prev;
        DListNode next;
        public DListNode(){}
        public DListNode(int key,int val){
            this.key = key;
            this.val = val;
        }
        // use when put with same key
        public void setVal(int val){
            this.val = val;
        }
    }
}
```

---



---

#### #149-max-points-on-a-line-hard

Given *n* points on a 2D plane, find the maximum number of points that lie on the same straight line.



---

#### #156-binary-tree-upside-down-medium

Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

For example:
Given a binary tree `{1,2,3,4,5}`,

```
    1
   / \
  2   3
 / \
4   5
```

return the root of the binary tree `[4,5,2,#,#,3,1]`.

```
   4
  / \
 5   2
    / \
   3   1  
   
    1
   / 
  2 -- 3
 / 
4 -- 5
```

```java
    public TreeNode upsideDownBinaryTree(TreeNode root) {
        //     1
        //    / \
        //   2 - 3
        //  / \
        // 4 - 5    
        TreeNode curr = root;
        TreeNode next = null, prev = null, right = null;
        while(curr != null){
            next = curr.left;   // save left
            
            curr.left = right;
            right = curr.right;
            curr.right = prev;
            
            prev = curr;
            curr = next;
        }
        return prev;
    }
```

---



---

#### #163-missing-ranges-medium

Given a sorted integer array where **the range of elements are in the inclusive range [lower, upper]**, return its missing ranges.

For example, given `[0, 1, 3, 50, 75]`, *lower* = 0 and *upper* = 99, return `["2", "4->49", "51->74", "76->99"].`

**Corner cases:  Integer.min, Integer.max**  [#228-summary-ranges-medium](#228-summary-ranges-medium)

```java
    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        List<String> result = new ArrayList<>();
        if(nums==null)
            return result;
        int head = lower;
        for(int i=0; i<nums.length; i++){
            // deal with corner case
            // [-2147483648,-2147483648,0,2147483647,2147483647]
            // -2147483648
            // 2147483647
            if(nums[i] == Integer.MIN_VALUE){
                // tail cannot be nums[i] - 1
                head = nums[i] + 1;
                continue;
            }
            int tail = nums[i] - 1;
            
            if(tail >= head)
                result.add(head + (tail>head? "->"+tail : ""));           
            // deal with corner case, return here
            if(nums[i] == Integer.MAX_VALUE)
                return result;
            head = nums[i] + 1;
        }
        // deal with last num
        if(head <= upper)
            result.add(head + (upper>head? "->"+upper : ""));
        return result;
    }
```

---







---

#### #165-compare-version-numbers-medium

Compare two version numbers *version1* and *version2*.
If *version1* > *version2* return 1, if *version1* < *version2* return -1, otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the `.` character.
The `.` character does not represent a decimal point and is used to separate number sequences.
For instance, `2.5` is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Here is an example of version numbers ordering:

```
0.1 < 1.1 < 1.2 < 13.37  
01 = 1, 1.0 = 1
```

```java
    public int compareVersion(String version1, String version2) {
        // . match a char
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        for(int i=0,j=0;i<v1.length||j<v2.length;){
            int num1 = i >= v1.length ? 0 : Integer.parseInt(v1[i++]);
            int num2 = j >= v2.length ? 0 : Integer.parseInt(v2[j++]);
            if(num1 == num2)
                continue;
            else if(num1 < num2)
                return -1;
            else
                return 1;
        }
        return 0;
    }
```

---



---

#### #169-majority-element-easy

Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Can use sorting as well** [#229-majority-element-ii-medium](#229-majority-element-ii-medium)

```java
    public int majorityElement(int[] nums) {
        // Boyer-Moore Voting Algorithm
        int result = 0, count = 0;
        for(int num : nums){
            if(count == 0)
                result = num;
            count += num == result ? 1 : -1;
        }
        return result;
    }
```







---

#### 200. Number of Islands (medium)

Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**\*Example 1:* Answer: 1**

```
11110
11010
11000
00000
```

**\*Example 2:*** Answer: 3

```
11000
11000
00100
00011
```

**dfs approach time O(mn), space O(mn) worst** 

```java
    public int numIslands(char[][] grid) {
        if(grid==null || grid.length==0 || grid[0].length==0)
            return 0;
        // dfs approach, connected component idea
        int m = grid.length, n = grid[0].length;
        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // if 1, count ++, traverse neighbor
                if(grid[i][j] == '1'){
                    count ++;
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }
    private void dfs(char[][] grid,int i,int j){
        int m = grid.length, n = grid[0].length;
        // if out of bound, or not island
        if(i<0 || i>=m || j<0 || j>=n || grid[i][j]=='0')
            return;
        grid[i][j] = '0';   // set visited
        // visit up down left right
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
```

**BFS approach, time O(mn), space O(min(m,n))**

```java
    public int numIslands(char[][] grid) {
        // bfs approach
        if(grid==null || grid.length==0 || grid[0].length==0)
            return 0;
        int count = 0;
        int m = grid.length, n = grid[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                // only care about 1
                if(grid[i][j] == '1'){
                    count ++;
                    grid[i][j] = '0';
                    int[] curr = {i,j};
                    Queue<int[]> queue = new LinkedList<>();
                    queue.offer(curr);
                    while(!queue.isEmpty()){
                        curr = queue.poll();
                        int row = curr[0], col = curr[1];
                        if(row-1>=0 && grid[row-1][col] == '1'){
                            queue.offer(new int[]{row-1,col});
                            grid[row-1][col] = '0';
                        }
                        if(row+1<m && grid[row+1][col] == '1'){
                            queue.offer(new int[]{row+1,col});
                            grid[row+1][col] = '0';
                        }
                        if(col-1>=0 && grid[row][col-1] == '1'){
                            queue.offer(new int[]{row,col-1});
                            grid[row][col-1] = '0';
                        }
                        if(col+1<n && grid[row][col+1] == '1'){
                            queue.offer(new int[]{row,col+1});
                            grid[row][col+1] = '0';
                        }                        
                    }
                }
            }
        }
        return count;
    }
```

---

#### #201-bitwise-and-of-numbers-range-medium

Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

For example, given the range [5, 7], you should return 4.

```java
    public int rangeBitwiseAnd(int m, int n) {
        // right shift, all tail digits are 0
        // until m == n, this is the head
        // append 0 tail to head
        if(m == 0)
            // 0 & x == 0
            return 0;
        int tailLen = 0;
        while(m != n){
            m >>= 1;
            n >>= 1;
            tailLen ++;
        }
        return m << tailLen;
    }
```

------



---

#### #204-count-primes-easy

**Description:**

Count the number of prime numbers less than a non-negative number, **n**.

```java
    public int countPrimes(int n) {
        if(n < 1)
            return 0;
        // indicate whether prime
        boolean[] prime = new boolean[n]; 
        Arrays.fill(prime,true);
        int count = 0;
        for(int i=2; i<n; i++){
            if(prime[i]){
                count ++;
                for(int j=2; i*j<n; j++){
                    prime[i * j] = false;
                }
            }
        }
        return count;
    }
```

---





---

#### #217-contains-duplicate-easy

Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

**Use HashSet: time O(n), space O(n)**

**Use Sort: time O(nlgn), space O(1)**

---

#### #219-contains-duplicate-ii-easy

Given an array of integers and an integer *k*, find out whether there are two distinct indices *i* and *j* in the array such that **nums[i] = nums[j]** and the **absolute** difference between *i* and *j* is at most *k*.

```java
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        if(k<=0) return false;
        Set<Integer> visited = new HashSet<>();
        for(int i=0;i<nums.length;i++){
            if(i-k>0) visited.remove(nums[i-k-1]);
            if(!visited.add(nums[i])) return true;
        }
        return false;
    }
```

---

#### #220-contains-duplicate-iii-medium

Given an array of integers, find out whether there are two distinct indices *i* and *j* in the array such that the **absolute** difference between **nums[i]** and **nums[j]** is at most *t* and the **absolute** difference between *i* and *j* is at most *k*. **Use TreeSet**

```java
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        // abs(nums[i] - nums[j]) <= t
        // abs(i - j) <= k
        // O(n log k)
        if(nums==null || nums.length==0 || t<0 || k<0)
            return false;
        TreeSet<Integer> set = new TreeSet<>();
        for(int i=0; i<nums.length; i++){
            // maintance a window
            if(i - k > 0)
                set.remove(nums[i - k - 1]);
            // floor: greatest less or equal to
            // ceiling: smallest greater or equal to
            // NOTICE: overflow
            Integer left = set.ceiling(Integer.MIN_VALUE + t < nums[i] ? 
                                       nums[i] - t : Integer.MIN_VALUE);
            Integer right = set.floor(Integer.MAX_VALUE - t > nums[i] ?
                                     nums[i] + t : Integer.MAX_VALUE);
            if(left != null && left <= nums[i] ||
              right != null && right >= nums[i])
                return true;
            // add set
            set.add(nums[i]);
        }
        return false;
    }
```





---

#### #223-rectangle-area-medium

Find the total area covered by two **rectilinear** rectangles in a **2D** plane.

Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.

![Rectangle Area](https://leetcode.com/static/images/problemset/rectangle_area.png)

Assume that the total area is never beyond the maximum possible value of **int**.

```java
    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        // FIND INTERSECTION
        // x axis: A---C E---F
        int X = 0;
        if(C-A>G-E && E>=A && G<=C)
            X = G - E;
        else if(C-A<=G-E && A>=E && C<=G)
            X = C - A;
        // after above 2, low priority
        else if(G>A && E<A)
            X = G - A;
        else if(E<C && G>C)
            X = C - E;
        // y axis: B---D F---H
        int Y = 0;
        // check include relation first
        if(D-B>H-F && F>=B && H<=D)
            Y = H - F;
        else if(D-B<=H-F && B>=F && D<=H)
            Y = D - B;
        else if(H>B && F<B)
            Y = H - B;
        else if(F<D && H>D)
            Y = D - F;        
        // compute
        int area1 = (C-A) * (D-B);
        int area2 = (G-E) * (H-F);
        int area3 = X * Y;
        return area1 + area2 - area3;

    }
```

---



---

#### #228-summary-ranges-medium

Given a sorted integer array without duplicates, return the summary of its ranges.

**Example 1:**

```
Input: [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
```

**Example 2:**

```
Input: [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
```

```java
    public List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        if(nums==null || nums.length==0)
            return result;
        Integer head = null;
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<nums.length; i++){
            if(head == null)
                head = nums[i];
            if(i<nums.length-1 && nums[i]+1==nums[i+1])
                continue;
            else{   // last one or new range
                sb.append(head);
                // notice one num
                if(head != nums[i])
                    sb.append("->"+nums[i]);
                result.add(sb.toString());
                sb.setLength(0);
                head = null;
            }
        }
        return result;
    }
```

```java
    public List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        if(nums==null || nums.length==0)
            return result;
        for(int head=0; head<nums.length; head++){
            int tail = head;
            while(tail<nums.length-1 && nums[tail]+1==nums[tail+1])
                tail ++;
            if(head != tail)
                result.add(nums[head] + "->" + nums[tail]);
            else
                result.add(nums[head] + "");
            head = tail;
        }
        return result;
    }
```

---

#### #229-majority-element-ii-medium

Given an integer array of size *n*, find all elements that appear more than `⌊ n/3 ⌋` times. The algorithm should run in linear time and in O(1) space.

**Check existence first!!**

```java
    public List<Integer> majorityElement(int[] nums) {
        // majority vote
        List<Integer> result = new ArrayList<>();
        if(nums == null || nums.length == 0)
            return result;
        int major1 = 0, major2 = 0, cnt1 = 0, cnt2 = 0;
        for(int num : nums){
            // order matters
            if(major1 == num)
                cnt1 ++;
            else if(major2 == num)
                cnt2 ++;             
            else if(cnt1 == 0){
                major1 = num;
                cnt1 ++;
            }else if(cnt2 == 0){
                major2 = num;  
                cnt2 ++;
            }else{
                cnt1 --;
                cnt2 --;
            }
        }
        // 2nd pass, cnt accurance
        cnt1 = cnt2 = 0;
        for(int num : nums){
            if(major1 == num)
                cnt1 ++;
            else if(major2 == num)
                cnt2 ++;
        }
        // add to result
        if(cnt1 > nums.length / 3)
            result.add(major1);
        if(cnt2 > nums.length / 3)
            result.add(major2);
        return result;
    }
```

---







---

#### #241-different-ways-to-add-parentheses-medium

Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are `+`, `-` and `*`.

Example 1

Input: `"2-1-1"`.

```
((2-1)-1) = 0
(2-(1-1)) = 2
```

Output: `[0, 2]`

Example 2

Input: `"2*3-4*5"`

```
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
```

Output: `[-34, -14, -10, -10, 10]`

```java
    public List<Integer> diffWaysToCompute(String input) {
        // use recursion
        List<Integer> result = new ArrayList<>();
        for(int i=0;i<input.length();i++){
            char c = input.charAt(i);
            // divide input to two part
            if(c=='+' || c=='-' || c=='*'){
                String left = input.substring(0,i);
                String right = input.substring(i+1);
                List<Integer> list1 = diffWaysToCompute(left);
                List<Integer> list2 = diffWaysToCompute(right);
                // combine to subset
                for(int num1 : list1){
                    for(int num2 : list2){
                        int temp = 0;
                        switch(c){
                            case '+': 
                                temp = num1 + num2;
                                break;
                            case '-':
                                temp = num1 - num2;
                                break;
                            case '*':
                                temp = num1 * num2;
                                break;
                        }
                        // one possible result
                        result.add(temp);
                    }
                }
            }
        }
        // case theres no operator in input
        if(result.size() == 0)
            result.add(Integer.parseInt(input));
        return result;
    }
```

**add memory and optimization**

```java
    public List<Integer> diffWaysToCompute(String input) {
        Map<String,List<Integer>> map = new HashMap<>();
        return dfs(input,map,0,input.length());
    }
    private List<Integer> dfs(String input,Map<String,List<Integer>> map,int start,int end){
        // use recursion
        // if this expression is saved
        String expression = input.substring(start,end);
        if(map.containsKey(expression))
            return map.get(expression);
        List<Integer> result = new ArrayList<>();
        for(int i=start;i<end;i++){
            char c = input.charAt(i);
            // divide input to two part
            if(c=='+' || c=='-' || c=='*'){
                List<Integer> list1 = dfs(input,map,start,i);
                List<Integer> list2 = dfs(input,map,i+1,end);
                // combine to subset
                for(int num1 : list1){
                    for(int num2 : list2){
                        int temp = 0;
                        switch(c){
                            case '+': 
                                temp = num1 + num2;
                                break;
                            case '-':
                                temp = num1 - num2;
                                break;
                            case '*':
                                temp = num1 * num2;
                                break;
                        }
                        // one possible result
                        result.add(temp);
                    }
                }
            }
        }
        // case theres no operator in input
        if(result.size() == 0)
            result.add(Integer.parseInt(expression));
        map.put(expression,result);
        return result;        
    }
```

---



---

#### #243-shortest-word-distance-easy

Given a list of words and two words *word1* and *word2*, return the shortest distance between these two words in the list.

For example,
Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

Given *word1* = `“coding”`, *word2* = `“practice”`, return 3.
Given *word1* = `"makes"`, *word2* = `"coding"`, return 1.

**Note:**
You may assume that *word1* **does not equal to** *word2*, and *word1* and *word2* are both in the list.

```java
    public int shortestDistance(String[] words, String word1, String word2) {
        if(words==null || words.length==0)
            return 0;
        int idx1 = -1, idx2 = -1, min = words.length;
        for(int i=0;i<words.length;i++){
            if(words[i].equals(word1))
                idx1 = i;
            else if(words[i].equals(word2))
                idx2 = i;
            // need to check whether idx are set
            if(idx1!=-1 && idx2!=-1)
                min = Math.min(min,Math.abs(idx1-idx2));
        }
        return min;
    }
```

---

#### #244-shortest-word-distance-ii-medium

This is a **follow up** of [Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance). The only difference is now you are given the list of words and your method will be called *repeatedly* many times with different parameters. How would you optimize it?

Design a class which receives a list of words in the constructor, and implements a method that takes two words *word1* and *word2* and return the shortest distance between these two words in the list.

For example,
Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

Given *word1* = `“coding”`, *word2* = `“practice”`, return 3.
Given *word1* = `"makes"`, *word2* = `"coding"`, return 1.

**Note:**
You may assume that *word1* **does not equal to** *word2*, and *word1* and *word2* are both in the list.

```java
class WordDistance {
    Map<String,List<Integer>> map;
    public WordDistance(String[] words) {
        map = new HashMap<>();
        for(int i=0;i<words.length;i++){
            if(!map.containsKey(words[i]))
                map.put(words[i],new ArrayList<>());
            map.get(words[i]).add(i);
        }
    }
    
    public int shortest(String word1, String word2) {
        List<Integer> l1 = map.get(word1);
        List<Integer> l2 = map.get(word2);
        int min = Integer.MAX_VALUE;
        int idx1 = 0, idx2 = 0;
        // utilize two pointer to optimize
        while(idx1<l1.size() && idx2<l2.size()){
            min = Math.min(min,Math.abs(l1.get(idx1)-l2.get(idx2)));
            if(l1.get(idx1) < l2.get(idx2))
                idx1++;
            else
                idx2++;
        }
        return min;
    }
}
```

---

#### #245-shortest-word-distance-iii-medium

This is a **follow up** of [Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance). The only difference is now *word1* could be the same as *word2*.

Given a list of words and two words *word1* and *word2*, return the shortest distance between these two words in the list.

*word1* and *word2* may be the same and they represent two individual words in the list.

For example,
Assume that words = `["practice", "makes", "perfect", "coding", "makes"]`.

Given *word1* = `“makes”`, *word2* = `“coding”`, return 1.
Given *word1* = `"makes"`, *word2* = `"makes"`, return 3.

**Note:**
You may assume *word1* and *word2* are both in the list.

```java
    public int shortestWordDistance(String[] words, String word1, String word2) {
        if(words==null || words.length==0)
            return 0;
        int min = words.length;
        int idx1 = -1, idx2 = -1;
        for(int i=0; i<words.length; i++){
            if(words[i].equals(word1))
                idx1 = i;
            if(words[i].equals(word2)){
                if(word1.equals(word2))
                // set idx1 to prev idx2
                    idx1 = idx2;
                idx2 = i;
            }
            if(idx1 != -1 && idx2 != -1){
                min = Math.min(min,Math.abs(idx1-idx2));
            }
        }
        return min;
    }
```

**quicker**

```java
    public int shortestWordDistance(String[] words, String word1, String word2) {
        if(words==null || words.length==0)
            return 0;
        int min = words.length;
        int idx1 = -1, idx2 = -1;
        if(word1.equals(word2)){
            for(int i=0;i<words.length;i++){
                if(words[i].equals(word1)){
                    if(idx1 == -1)
                        idx1 = i;
                    else{
                        min = Math.min(min,i-idx1);
                        idx1 = i;
                    }
                }
            }            
        }else{
            for(int i=0;i<words.length;i++){
                if(words[i].equals(word1))
                    idx1 = i;
                else if(words[i].equals(word2))
                    idx2 = i;
                if(idx1!=-1 && idx2!=-1)
                    min = Math.min(min,Math.abs(idx1-idx2));
            }
        }
        return min;
    }
```

---



---

#### #263-ugly-number-easy

Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include `2, 3, 5`. For example, `6, 8` are ugly while `14` is not ugly since it includes another prime factor `7`.

**Note:**

1. `1` is typically treated as an ugly number.
2. Input is within the 32-bit signed integer range.

```java
    public boolean isUgly(int num) {
        if(num == 0)
            return false;
        if(num == 1)
            return true;
        while(num % 2 == 0) num /= 2;
        while(num % 3 == 0) num /= 3;
        while(num % 5 == 0) num /= 5;
        return num == 1;
    }
```

---

#### #264-ugly-number-ii-medium

Write a program to find the `n`-th ugly number.

Ugly numbers are positive numbers whose prime factors only include `2, 3, 5`. For example, `1, 2, 3, 4, 5, 6, 8, 9, 10, 12` is the sequence of the first `10` ugly numbers.

Note that `1` is typically treated as an ugly number, and *n* **does not exceed 1690**.

The idea of this solution is from this page:<http://www.geeksforgeeks.org/ugly-numbers/>

```java
    public int nthUglyNumber(int n) {
        // pointer for multi of 2,3,5
        int i2 = 0, i3 = 0, i5 = 0;
        // dp 
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i=1; i<n; i++){
            int ugly = Math.min(dp[i5]*5,
                       Math.min(dp[i2]*2,
                                dp[i3]*3));
            dp[i] = ugly;
            // check to increase pointer
            if(dp[i2]*2 == ugly) i2++;
            if(dp[i3]*3 == ugly) i3++;
            if(dp[i5]*5 == ugly) i5++;
        }
        return dp[n-1];
    }
```

---





---

#### #271-encode-and-decode-strings-medium

Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

```java
public class Codec {

    // Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        // count#str
        StringBuilder sb = new StringBuilder();
        for(String str : strs){
            // append one by one
            sb.append(str.length() + "#" + str);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> result = new ArrayList<>();
        int i = 0;
        while(i < s.length()){
            int j = i;
            while(s.charAt(j) != '#')
                j ++;
            int len = Integer.parseInt(s.substring(i,j));
            result.add(s.substring(j+1,j+1+len));
            i = j + 1 + len;
        }
        return result;
    }
}
// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(strs));
```

---



---

#### #279-perfect-squares-medium

Given a positive integer *n*, find the least number of perfect square numbers (for example, `1, 4, 9, 16, ...`) which sum to *n*.

For example, given *n* = `12`, return `3` because `12 = 4 + 4 + 4`; given *n* = `13`, return `2` because `13 = 4 + 9`.

```java
    public int numSquares(int n) {
        // use dp check prev sum
        int[] dp = new int[n+1];
        // dp iteration
        for(int i=1; i<=n; i++){
            // for num i, check all squares
            // curr square + (i-square)
            int min = Integer.MAX_VALUE;
            for(int j=1; j*j<=i; j++){
                // dp[j*j] is 1
                // so population not needed
                min = Math.min(min, dp[i-j*j] + 1);
            }      
            dp[i] = min;
        }
        return dp[n];
    }
```

---



---

#### #313-supper-ugly-number-medium

Write a program to find the nth super ugly number.

Super ugly numbers are positive numbers whose all prime factors are in the given prime list `primes` of size `k`. For example, `[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] `is the sequence of the first 12 super ugly numbers given `primes` = `[2, 7, 13, 19]` of size 4.

**Note:**
(1) `1` is a super ugly number for any given `primes`.
(2) The given numbers in `primes` are in ascending order.
(3) 0 < `k` ≤ 100, 0 < `n` ≤ 106, 0 < `primes[i]` < 1000.
(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.

```java
    public int nthSuperUglyNumber(int n, int[] primes) {
        // use idea of ugly number ii
        // array to save result, first is 1
        int[] nums = new int[n];
        nums[0] = 1;
        // array to save index
        int[] idx = new int[primes.length];
        for(int i=1; i<n; i++){
            // find min to be curr ugly num
            int ugly = Integer.MAX_VALUE;
            for(int j=0; j<idx.length; j++){
                // nums[idx for j] * primes[j]
                int candidate = primes[j] * nums[idx[j]];
                ugly = Math.min(ugly,candidate);
            }
            // set curr result
            nums[i] = ugly;
            // update index for all primes
            for(int j=0; j<idx.length; j++){
                int prev = nums[idx[j]];
                if(prev * primes[j] == ugly)
                    idx[j] ++;
            }
        }
        return nums[n-1];
    }
```

---





---

#### #335-self-crossing-hard

You are given an array *x* of `n` positive numbers. You start at point `(0,0)` and moves `x[0]` metres to the north, then `x[1]` metres to the west, `x[2]` metres to the south, `x[3]` metres to the east and so on. In other words, after each move your direction changes counter-clockwise.

Write a one-pass algorithm with `O(1)` extra space to determine, if your path crosses itself, or not.

**Example 1:**

```
Given x = [2, 1, 1, 2],
?????
?   ?
???????>
    ?

Return true (self crossing)
```

**Example 2:**

```
Given x = [1, 2, 3, 4],
????????
?      ?
?
?
?????????????>

Return false (not self crossing)
```

**Example 3:**

```
Given x = [1, 1, 1, 1],
?????
?   ?
?????>

Return true (self crossing)
```

```java
    public boolean isSelfCrossing(int[] x) {
        // i could cross with i-3, i-4, i-5
        if(x==null || x.length<=3)
            return false;
        // start from 3
        for(int i=3; i<x.length; i++){
            // check i & i-3
            // 7 4: 7>=5, 6>=4
            if(x[i]>=x[i-2] && x[i-1]<=x[i-3])
                return true;
            // check i & i-4
            // 7 3: 7+3>=5, 6==4
            if(i>=4 && x[i]+x[i-4]>=x[i-2] && x[i-1]==x[i-3])
                return true;
            // check i & i-5
            // 7 2: 7+3>=5, 5>=3, 6+2>=4, 6<=4 !(4>=2)
            if(i>=5 && x[i]+x[i-4]>=x[i-2] && x[i-2]>=x[i-4] &&
              x[i-1]+x[i-5]>=x[i-3] && x[i-1]<=x[i-3])
                return true;
        }
        return false;
    }
```

---



---

#### #371-sum-of-two-integers-easy

Calculate the sum of two integers *a* and *b*, but you are **not allowed** to use the operator `+` and `-`.

**Example:**
Given *a* = 1 and *b* = 2, return 3.

**Iteration:**

```java
    public int getSum(int a, int b) {
        int sum = a, carry = b;
        while(carry != 0){
            int nextSum = sum ^ carry;
            int nextCarry = (sum & carry) << 1;
            sum = nextSum;
            carry = nextCarry;
        }
        return sum;
    }
```

**Recursion:**

```java
    public int getSum(int a, int b) {
        if(b == 0)
            return a;
        int sum = a ^ b;
        int carry = (a & b) << 1;
        return getSum(sum,carry);
    }
```

---





---

#### #384-shuffle-an-array-medium

Shuffle a set of numbers without duplicates.

**Example:**

```
// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();
```

```java
class Solution {
    int[] nums = null;
    Random random;
    public Solution(int[] nums) {
        this.nums = nums;
        random = new Random();
    }
    
    /** Resets the array to its original configuration and return it. */
    public int[] reset() {
        return nums;
    }
    
    /** Returns a random shuffling of the array. */
    public int[] shuffle() {
        int[] copy = nums.clone();
        // i is at i P = 1/i+1
        // i is not at i P = 1-1/i+1 = i/i+1
        // i at the other i P = 1/ i;
        // i at each location 0 to i is 1/i+1
        for(int i=1;i<copy.length;i++){
            // nextInt(a) a is exclusive
            int j = random.nextInt(i+1);
            swap(copy,i,j);
        }
        return copy;
    }
    
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

---



---

#### #388-longest-absolute-file-path-medium

Suppose we abstract our file system by a string in the following manner:

The string `"dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"` represents:

```
dir
    subdir1
    subdir2
        file.ext
```

The directory `dir` contains an empty sub-directory `subdir1` and a sub-directory `subdir2` containing a file `file.ext`.

The string `"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"` represents:

```
dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext
```

The directory `dir` contains two sub-directories `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext` and an empty second-level sub-directory `subsubdir1`. `subdir2` contains a second-level sub-directory `subsubdir2` containing a file `file2.ext`.

We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is `"dir/subdir2/subsubdir2/file2.ext"`, and its length is `32` (not including the double quotes).

Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return `0`.

**Note:**

- The name of a file contains at least a `.` and an extension.
- The name of a directory or sub-directory will not contain a `.`.

Time complexity required: `O(n)` where `n` is the size of the input string.

Notice that `a/aa/aaa/file1.txt` is not the longest file path, if there is another path `aaaaaaaaaaaaaaaaaaaaa/sth.png`.

```java
    public int lengthLongestPath(String input) {
        // use stack, 
        // for a level, stack saves only higher level len
        // if same level exit then pop
        if(input == null)
            return 0;
        Stack<Integer> stack = new Stack<>();
        stack.push(0);  // dummy bottom
        int maxLen = 0;
        // every \n => a folder or a file
        for(String s : input.split("\n")){
            // define the level
            // first level -1+1=0, \t=>1, \t\t=>2
            int level = s.lastIndexOf("\t") + 1;
            // check whether stack has only higher level
            // l0=>size 1,l1=>size 2,l2=>size 3
            while(stack.size() > level+1) // find parent
                stack.pop();
            // push curr level len to stack, remove \t, add /
            int len = stack.peek() + s.length() - level + 1;
            stack.push(len);
            // if it's a file, compute maxlen
            if(s.contains("."))
                maxLen = Math.max(maxLen,len - 1);  // remove /
        }
        return maxLen;
    }
```

---



---

#### #406-queue-reconstruction-by-height-medium

Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers `(h, k)`, where `h` is the height of the person and `k` is the number of people in front of this person who have a height greater than or equal to `h`. Write an algorithm to reconstruct the queue.

**Note:**
The number of people is less than 1,100.

**Example**

```
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

```java
    public int[][] reconstructQueue(int[][] people) {
        // height decrease, count increase, insert
        if(people==null || people.length==0 || people[0].length==0)
            return people;
        Arrays.sort(people,new Comparator<int[]>(){
            @Override
            public int compare(int[] a,int[] b){
                if(a[0] != b[0])    // decrease
                    return b[0] - a[0];
                else    // increase
                    return a[1] - b[1];
            }
        });
        List<int[]> result = new LinkedList<>();
        for(int[] p : people)
            result.add(p[1],p);
        return result.toArray(new int[people.length][2]);
    }
```



---



---

#### 419. Battleships in a Board (medium)

Given an 2D board, count how many battleships are in it. The battleships are represented with 

`'X'`s, empty slots are represented with `'.'`s. You may assume the following rules:

- You receive a valid board, made of only battleships or empty slots.
- Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape `1xN` (1 row, N columns) or `Nx1` (N rows, 1 column), where N can be of any size.
- At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.

**Example:**

```
X..X
...X
...X
```

In the above board there are 2 battleships.

**Invalid Example:**

```
...X
XXXX
...X
```

This is an invalid board that you will not receive - as battleships will always have a cell separating between them.

```java
    public int countBattleships(char[][] board) {
        // idea only find ship head, left top cell
        if(board==null || board.length==0 || board[0].length==0)
            return 0;
        final int m = board.length, n = board[0].length;
        int count = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j] == '.')
                    continue;
                if(i>0 && board[i-1][j] == 'X')
                    continue;
                if(j>0 && board[i][j-1] == 'X')
                    continue;
                count ++;
            }
        }
        return count;
    }
```

---



---

#### #443-string-compression-easy

Given an array of characters, compress it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a **character** (not int) of length 1.

After you are done **modifying the input array in-place**, return the new length of the array.

**Follow up:**
Could you solve it using only O(1) extra space?

**Example:**

```
Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
```

**Note:**

1. All characters have an ASCII value in `[35, 126]`.
2. `1 <= len(chars) <= 1000`.

```java
    public int compress(char[] chars) {
        if(chars==null || chars.length==0)
            return 0;
        // start for result tail, end for curr
        int start = 0, end = 0;
        while(end < chars.length){
            char curr = chars[end];
            int count = 1;
            // count same char
            while(end<chars.length-1 && chars[end]==chars[end+1]){
                count ++;
                end ++;
            }
            // put curr char down
            chars[start++] = chars[end++];
            // then add count
            if(count != 1)
                for(char c : String.valueOf(count).toCharArray())
                    chars[start++] = c;
        }
        return start;
    }
```

---



---

#### #463-island-perimeter-easy

**Example:**

```
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:
```

![img](https://leetcode.com/static/images/problemset/island.png)

```java
    public int islandPerimeter(int[][] grid) {
        if(grid==null || grid.length==0 || grid[0].length==0)
            return 0;
        final int row = grid.length;
        final int col = grid[0].length;
        int count = 0;
        for(int i=0; i<row; i++){
            for(int j=0; j<col; j++){
                if(grid[i][j] == 0)
                    continue;
                // check up and left, if nei is 1, remove edge
                count += 4; // default 4 added first
                // -2 : two block double edge remove
                if(i > 0 && grid[i-1][j] == 1)
                    count -= 2; 
                if(j > 0 && grid[i][j-1] == 1)
                    count -= 2;
            }
        }
        return count;
    }
```

---



---

#### #476-number-complement-easy

Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.

**Note:**

1. The given integer is guaranteed to fit within the range of a 32-bit signed integer.
2. You could assume no leading zero bit in the integer’s binary representation.

**Example 1:**

```
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
```

**Example 2:**

```
Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
```

```java
    public int findComplement(int num) {
        // use 11111 - num
        int n = 1;
        while(n < num)
            n = n << 1 | 1;
        return n - num;
    }
```

---



---

#### #500-keyboard-row-easy

Given a List of words, return the words that can be typed using letters of **alphabet** on only one row's of American keyboard like the image below. 

![American keyboard](https://leetcode.com/static/images/problemset/keyboard.png)

**Example 1:**

```
Input: ["Hello", "Alaska", "Dad", "Peace"]
Output: ["Alaska", "Dad"]
```

**Note:**

1. You may use one character in the keyboard more than once.
2. You may assume the input string will only contain letters of alphabet.

```java
    public String[] findWords(String[] words) {
        List<String> result = new ArrayList<>();
        if(words==null || words.length==0)
            return result.toArray(new String[0]);
        // build map
        String[] rows = {"QWERTYUIOP","ASDFGHJKL","ZXCVBNM"};
        Map<Character,Integer> map = new HashMap<>();
        for(int i=0;i<rows.length;i++)
            for(char c : rows[i].toCharArray())
                map.put(c,i);
        // add to result
        WORDS:
        for(String word : words){
            if(word.equals(""))
                continue;
            int idx = map.get(Character.toUpperCase(word.charAt(0)));
            for(int i=1;i<word.length();i++){
                if(map.get(Character.toUpperCase(word.charAt(i))) != idx)
                    continue WORDS;
            }
            result.add(word);
        }
        return result.toArray(new String[result.size()]);
    }
```

```java
    public String[] findWords(String[] words) {
        List<String> result = new ArrayList<>();
        if(words==null || words.length==0)
            return result.toArray(new String[0]);
        String regex = "[QWERTYUIOP]*|[ASDFGHJKL]*|[ZXCVBNM]*";
        for(String word : words){
            if(word.toUpperCase().matches(regex)){
                result.add(word);
            }
        }
        return result.toArray(new String[result.size()]);
    }
```





---

#### #560-subarray-sum-equals-k-medium

Given an array of integers and an integer **k**, you need to find the total number of continuous subarrays whose sum equals to **k**.

**Example 1:**

```
Input:nums = [1,1,1], k = 2
Output: 2
```

**Note:**

1. The length of the array is in range [1, 20,000].
2. The range of numbers in the array is [-1000, 1000] and the range of the integer **k** is [-1e7, 1e7].

```java
    public int subarraySum(int[] nums, int k) {
        if(nums==null || nums.length==0)
            return 0;
        // use map to save curr sum & count
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,1);   // 
        int count = 0, sum = 0;
        for(int num : nums){
            sum += num;
            count += map.getOrDefault(sum-k,0);
            map.put(sum,map.getOrDefault(sum,0)+1);
        }
        return count;
    }
```

---



---

#### #604-compressed-string-iterator-easy

Design and implement a data structure for a compressed string iterator. It should support the following operations: `next` and `hasNext`.

The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.

`next()` - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.
`hasNext()` - Judge whether there is any letter needs to be uncompressed.

**Note:**
Please remember to **RESET** your class variables declared in StringIterator, as static/class variables are **persisted across multiple test cases**. Please see [here](https://leetcode.com/faq/#different-output) for more details.

**Example:**

```
StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");

iterator.next(); // return 'L'
iterator.next(); // return 'e'
iterator.next(); // return 'e'
iterator.next(); // return 't'
iterator.next(); // return 'C'
iterator.next(); // return 'o'
iterator.next(); // return 'd'
iterator.hasNext(); // return true
iterator.next(); // return 'e'
iterator.hasNext(); // return false
iterator.next(); // return ' '
```

```java
class StringIterator {
    // use int[2] save char, count
    // use queue
    Queue<int[]> queue;
    public StringIterator(String compressedString) {
        queue = new LinkedList<>();
        int len = compressedString.length();
        for(int i=0; i<len;){
            int[] pair = new int[2];
            pair[0] = compressedString.charAt(i);
            int j = i + 1;
            // num is before letters
            String cnt = "";
            while(j<len && compressedString.charAt(j)<'A'){
                cnt += compressedString.charAt(j);
                j ++;
            }
            pair[1] = Integer.parseInt(cnt);
            queue.offer(pair);
            i = j;
        }
    }
    
    public char next() {
        if(queue.isEmpty())
            return ' ';
        int[] pair = queue.peek();
        if(--pair[1] == 0)
            queue.poll();
        return (char) pair[0];
    }
    
    public boolean hasNext() {
        return !queue.isEmpty();
    }
}
```

---



---

#### #625-minimun-factorization-medium

Given a positive integer `a`, find the smallest positive integer `b` whose multiplication of each digit equals to `a`. 

If there is no answer or the answer is not fit in 32-bit signed integer, then return 0.

**Example 1**
Input:

```
48 
```

Output:

```
68
```

```java
    public int smallestFactorization(int a) {
        if(a < 9)
            return a;
        // try larger first
        long result = 0, multi = 1;
        for(int i=9; i>=2; i--){
            while(a % i == 0){
                a /= i;
                result += multi * i;
                if(result > Integer.MAX_VALUE)
                    return 0;
                multi *= 10;
            }
        }
        if(a != 1)
            return 0;
        return (int) result;
    }
```

---

#### #809-expressive-word-medium

Sometimes people repeat letters to represent extra feeling, such as "hello" -> "heeellooo", "hi" -> "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string.

For some given string S, a query word is *stretchy* if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters `c`, and add some number of the same character `c` to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long.

Given a list of query words, return the number of words that are stretchy. 

```
Example:
Input: 
S = "heeellooo"
words = ["hello", "hi", "helo"]
Output: 1
Explanation: 
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.
```

```java
    public int expressiveWords(String S, String[] words) {
        if(S==null || S.length()==0 || words==null || words.length==0)
            return 0;
        int count = 0;
        for(String word : words){
            // i for S <= j for word
            int i = 0, j = 0;
            while(i < S.length()){
                // S.char == word.char, keep going
                if(j<word.length() && S.charAt(i)==word.charAt(j)){
                    i++;
                    j++;
                // check S.char is extend?
                }else if(i>0 && S.charAt(i)==S.charAt(i-1) && 
                        i<S.length()-1 && S.charAt(i)==S.charAt(i+1)){ 
                        i += 2;
                // check S when j reach word tail
                }else if(i>1 && S.charAt(i)==S.charAt(i-1) && S.charAt(i)==S.charAt(i-2)){
                    i++;
                }else break;
                if(i==S.length() && j==word.length())
                    count++;
            }
            
        }
        return count;
    }
```



---

#### #814-binary-tree-pruning-medium

We are given the head node `root` of a binary tree, where additionally every node's value is either a 0 or a 1.

Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)

```java
    public TreeNode pruneTree(TreeNode root) {
        // can use no helper
        if(root == null)
            return root;
        root.left = pruneTree(root.left);
        root.right = pruneTree(root.right);
        // post order
        if(root.left==null && root.right==null && root.val==0)
            return null;
        return root;
    }
```



---

#### #817-linked-list-components-medium

We are given `head`, the head node of a linked list containing **unique integer values**.

We are also given the list `G`, a subset of the values in the linked list.

Return the number of connected components in `G`, where two values are connected if they appear consecutively in the linked list.

**Example 1:**

```
Input: 
head: 0->1->2->3
G = [0, 1, 3]
Output: 2
Explanation: 
0 and 1 are connected, so [0, 1] and [3] are the two connected components.
```

**Example 2:**

```
Input: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
Output: 2
Explanation: 
0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.
```

**Note:** 

- If `N` is the length of the linked list given by `head`, `1 <= N <= 10000`.
- The value of each node in the linked list will be in the range` [0, N - 1]`.
- `1 <= G.length <= 10000`.
- `G` is a subset of all values in the linked list.

```java
    public int numComponents(ListNode head, int[] G) {
        // use set, count tail of components
        Set<Integer> set = new HashSet<>();
        for(int num : G)
            set.add(num);
        int count = 0;
        while(head != null){
            // if contains curr:
            // 1. this is end
            // 2. not contain next (tail)
            if(set.contains(head.val) && 
               (head.next==null || !set.contains(head.next.val)))
                count ++;
            head = head.next;
        }
        return count;
    }
```

